

pp_addpm ({At=>'Top'},<<"EOPM");

use 5.10.0;



EOPM

our $VERSION = 0.01;
pp_setversion($VERSION);

pp_bless ("PDL::OCV");

pp_addhdr << 'EOH';
 	#include "tracker_wrapper.h"
	typedef TrackerWrapper trackerObj;
	typedef MatWrapper matObj;

EOH

pp_def ('set_image',
	Pars=>'m(k,l);',
	OtherPars=>'MatWrapper * mw',
	Code=>pp_line_numbers(__LINE__,
	'
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		int * x;
		int * y;
		MatSize($COMP(mw),x,y);
		if (((*x) == ks) && ((*y) == ls)) 
			setData($COMP(mw),$P(m),0);
		else
			$CROAK("Matrix size does not match!\n");

	'),
	Doc=><<"EOD",

=head2 set_image - update data of a Mat object. Size and type should match.

EOD

	);

pp_def('test_return',
	Pars=>'[o] a()',
	OtherPars=>'MatWrapper * mw',
	Code=>'$a()=44;',
	PMCode=>'
	sub test_return {
		my $a=zeroes(4);
		my $mw;
		_test_return_int($a,$$mw);
		say "test_return $a";
		return ($a,$mw);

	}',
	);
pp_def('new_mat',
	Pars=>'float m(k,l);',
	OtherPars=>'MatWrapper * mwi',
	Code=>pp_line_numbers(__LINE__,'
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		MatWrapper *mw = newMat(ks,ls,cvT.f32c1,$P(m));
		//newMat($COMP(mwi),ks,ls,cvT.f32c1,$P(m));
		$COMP(mwi)=mw;
		printf ("newMat finished.");
		printf ("c new_mat at: %f", MatAt($COMP(mwi),48,48));
	'),
	PMCode=>pp_line_numbers(__LINE__,'
	sub new_mat{
		my ($m)=@_;
		my $mw = newM($m->dim(0),$m->dim(1),$m->type); #,$m->get_dataref);
		#my $mw = newMM(); 
		say "newM : ",keys %$mw;
		say "new mat $$mw";
		_new_mat_int($m,$$mw);
		say "new mat $$mw";
		say "(from newMat) mat_at :",mat_at($$mw,48,48);
	}',),
);

pp_def('init_tracker',
	Pars=>'float m(k,l); ushort [o] b(j=4);',
	# RedoDimsCode=>'$SIZE(l)=3*$SIZE(k); ',
	# GenericTypes => ['F'],
	# OtherPars=>'size_t tracker',
	OtherPars => 'TrackerWrapper *  twi; MatWrapper * mwi; ' ,#,struct MatWrapper * mw',
	Code=>pp_line_numbers(__LINE__,
	q{
		float myf=$m(k=>48,l=>48);
		printf("48 48%f\\n",myf);
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		bBox box;
		box.x=$b(j=>0);
		box.y=$b(j=>1);
		box.width=$b(j=>2);
		box.height=$b(j=>3);
		printf("ROI x %d y %d width %d height %d",box.x,box.y,box.width,box.height);
		//printf("ROI x %d y %d width %d height %d",box->x,box->y,box->width,box->height);

		printf("Hello World\n");
		newMat($COMP(mwi),ks,ls,cvT.f32c1,$P(m));
		int res=init_tracker($COMP(twi),$COMP(mwi),&box);
		printf("ROI x %d y %d width %d height %d\n",box.x,box.y,box.width,box.height);
		printf ("data from mat %f\n",MatAt($COMP(mwi),48,48));
		//$COMP(mwi)=mw;
		$b(j=>0)=box.x;
		$b(j=>1)=box.y;
		$b(j=>2)=box.width;
		$b(j=>3)=box.height;
		//printf ("box %d %d %d %d\n",$b);
	}
	 ),
        PMCode => pp_line_numbers(__LINE__,
<<'EOP',
sub init_tracker{
	my ($img, $tn, $box, $mat) = @_; 
	$box=zeroes(ushort,4) unless ( ref ($box) eq 'PDL');
	my $tracker;
	say "tn $tn box $box";
	$tracker = newT($tn);
	_init_tracker_int($img,$box,$$tracker,$$mat);
	#say "tracker pointer $$tracker, mat pointer $$mat, box $box";
	return ($tracker,$box,$mat);
}
EOP
),
	Doc=><<"EOD",

=head2 init_tracker - initialize OpenCV tracker 


Call with 
	
	($tracker,$box) = init_tracker ( $img, $tn, [$box, [ $mat ]] );

The first argument $img is the data, e.e. anything that fits a Mat object.
$tn is the tracker, in this order, strarting with 0: 
	
	["BOOSTING", "MIL", "KCF", "TLD","MEDIANFLOW", "GOTURN", "MOSSE", "CSRT"};

$box is a 4-integer array (x,y,width,height) holding the bounding box.
$mat is a reference to the Mat object.
$tracker is a reference to the tracker object. 



EOD
);

pp_def('update_tracker',
	Pars=>'float m(k,l); [o] b(j);',
	OtherPars => "TrackerWrapper * twi; MatWrapper * mwi",
	Code =>pp_line_numbers(__LINE__,
 	q{
   		printf ("twi %d ",$COMP(twi));
		struct bBox  box;
		MatWrapper * mw = $COMP(mwi);
		TrackerWrapper * tw = $COMP(twi);
		setData(mw,$P(m),cvT.f32c1);
		update_tracker(tw,mw,& box);
		$b(j=>0)=box.x;
		$b(j=>1)=box.y;
		$b(j=>2)=box.width;
		$b(j=>3)=box.height;
		//return;
	},
	),
        PMCode => pp_line_numbers(__LINE__,
<<'EOPM',
	sub update_tracker {
		my ($mat,$tw,$mw)=@_;
		_update_tracker_int($mat,$box,$$tw,$$mw);
		$box;
	}
EOPM
),
	Doc=>"update the tracker box.\n",
	);



pp_add_boot << 'EOB';

	tw_init();
	printf ("init done (autoinclude)\n");


EOB




pp_def ('mat_at',
	Pars=>'[o] m();',
	OtherPars=>'MatWrapper * mwi;int x;int y;',
	Code=>pp_line_numbers(__LINE__,
	'
		MatWrapper * mw=$COMP(mwi);
		float f=0.42;
		printf ("at: %d",$COMP(x));
		f=MatAt(mw,$COMP(x),$COMP(y));
		printf ("at: %f",f);
		$m()=f;
		printf ("at: %f",$m());
	',),
	PMCode=>pp_line_numbers(__LINE__,
	q{
	sub mat_at {
		my ($mw,$x,$y)=@_;
		my $o=zeroes(1);
		say "x $x y $y";
		say "mw ?",defined $$mw;
		_mat_at_int($o,$$mw,$x,$y);
		say "$o";
		$o;
	}
	},
	),
);

pp_addxs('','
MODULE = PDL::OCV PACKAGE = PDL::OCV

matObj *
newMM ()
 CODE:
MatWrapper * mw;
  RETVAL = mw;
 OUTPUT:
  RETVAL


matObj *
newM (c,r,t)
	int c
	int r
	int t
 CODE:
MatWrapper* mw = NULL;
 t=cvT.f32c1;
 mw=emptyMat(c,r,t);
  RETVAL = mw;
 OUTPUT:
  RETVAL

trackerObj *
newT (type)
  int type
 CODE:
 RETVAL = newTracker(type);
 OUTPUT:
  RETVAL

MODULE = PDL::OCV PACKAGE = trackerObj PREFIX = track_

void
track_DESTROY(tw)
  trackerObj * tw
 CODE:
  deleteTracker(tw);

MODULE = PDL::OCV PACKAGE = matObj PREFIX = mat_

void
mat_DESTROY(mw)
  matObj * mw
 CODE:
  deleteMat(mw);

');



pp_done();


__END__

