use strict;
pp_addpm ({At=>'Top'},<<'EOPM');
use 5.10.0;
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - This module interfaces perl/PDL and OpenCV.

=head1 SYNOPSIS

	use PDL::OpenCV;
	use PDL;
	use PDL::NiceSlice;

	...

	$mw->imshow();
	...
	$result=$mw->get_data;

=head1 DESCRIPTION

Use PDL::OpenCV to call OpenCV functions on your data using perl/PDL. This module
is the glue between the two tools. OpenCV and Perl's C++ interface are not
compatible, so a C layer is provided.

=cut

EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 KNOWN ISSUES

The number of functions in OpenCV is large, if you do not encounter what is needed,
there are fairly easy ways to create the wrappers. Look at ufunc/ofunc in opencv.pd
and gen_code in genwrap.pl. Please file a report if you do so.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
EOH

pp_def('cv_minmax',
	Pars => 'in(dim1,dim2,dim3); [o]m(k=4)',
	Code=>pp_line_numbers(__LINE__,'
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		if (l>1) $CROAK( "minMaxIdx only works on single channel (%d) arrays. \n",l);
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		double mymin;
		double mymax;
		//int * mil,mal;
		//printf("min %f max %f\n",mymin,mymax);
		cw_minMaxIdx(mw,& mymin,& mymax); //,mil,mal);
		deleteMat(mw);
		//printf("min %f max %f\n",mymin,mymax);
		$m(k=>0)=mymin;
		$m(k=>1)=mymax;
		//$m(k=>2)=mil;
		//$m(k=>3)=mal;
	'),
	);

sub protect_chars {
	my ($txt) = @_;
	$txt =~ s/>/E;gt#/g;
	$txt =~ s/</E;lt#/g;
	$txt =~ s/;/</g;
	$txt =~ s/#/>/g;
	return $txt;
}

sub ofunc {
    my ($name,$func,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $codestr = pp_line_numbers __LINE__, sprintf <<'EOF', $func;
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		$b() = cw_%s(mw);
		deleteMat(mw);
EOF
    pp_def($name,
	   Pars => 'in(dim1,dim2,dim3); [o]b()',
	   GenericTypes=>['N','D'],
	   NoPthread=>1,
	   PMCode => pp_line_numbers(__LINE__-1, qq{
		   sub $name {
			   my (\$self) = \@_;
			   my \$res=zeroes(ushort,1);
			   _${name}_int(\$self,\$res);
			   \$res;
		   }
	   },),
	   Code => $codestr,
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.
EOD
}

# generate functions.
ofunc($_,$_,"returns $_ of the Mat object. \n") for qw/rows cols channels/;

sub add_const {
  my ($args, $text) = @_;
  pp_add_exported($text);
  pp_addxs("int $text(@{[@$args ? join(',',map qq{@$_}, @$args) : '']})\nCODE:\n RETVAL = cw_const_$text(@{[join(',',map $_->[1], @$args)]});\nOUTPUT:\n RETVAL\n\n")
}

for my $bits (qw(8UC 8SC 16UC 16SC 32SC 32FC 64FC)) {
  add_const([], "CV_$bits$_") for 1..4;
  add_const([[qw(int n)]], "CV_$bits");
}

pp_done();
