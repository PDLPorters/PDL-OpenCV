use strict;
pp_addpm ({At=>'Top'},<<'EOPM');
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - PDL interface to OpenCV

=head1 SYNOPSIS

  use PDL::OpenCV::VideoCapture;
  use PDL::OpenCV::VideoWriter;
  my $vfile='t/Megamind.avi';
  my $vc = PDL::OpenCV::VideoCapture->new_uri($vfile);
  my $frame = $vc->read;
  my $writer = PDL::OpenCV::VideoWriter->new;
  $writer->open($outfile, 'MP4V', 20, (map $frame->dim($_), 1,2), 1);
  while (defined $frame) {
    $writer->write($frame);
  }

=head1 DESCRIPTION

Use PDL::OpenCV to call OpenCV functions on your data using Perl/PDL.

PDL data for this purpose must be dimensioned C<(channels,cols,rows)>
where C<channels> might be 1 if grayscale. This module will not use
heuristics to guess what you meant if you only supply 2-dimensional data.

As can be seen above, this distribution is structured to very closely
match the structure of OpenCV v4 itself. That means the submodules
match the "classes" and/or "modules" in OpenCV, with the obvious exception
of the C<Mat> class which needs special handling to thinly wrap ndarrays
going into and coming back from OpenCV.

This includes method/function names which are exactly the same
as in OpenCV, without being modified for the common Perl idiom
of snake_casing. This is intended to make the OpenCV documentation
trivially easy to use for the PDL binding (where a binding exists),
including available tutorials.

Where things do not work as you would expect from a PDL and/or OpenCV
point of view, and it is not documented as doing so, this is a bug -
please report it as shown at L</BUGS> below.

=cut
EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 BUGS

Please report bugs at L<https://github.com/PDLPorters/PDL-OpenCV/issues>,
or on the mailing list(s) at L<https://pdl.perl.org/?page=mailing-lists>.

=head1 AUTHOR

Ingo Schmid and the PDL Porters. Same terms as PDL itself.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
EOH

pp_def('minMaxIdx',
	Pars => 'in(l,c,r); double [o]min(); double [o]max()',
	Code=>pp_line_numbers(__LINE__,'
		if ($SIZE(l)>1) $CROAK( "minMaxIdx only works on single channel (got l=%"IND_FLAG") arrays.\n",$SIZE(l));
		MatWrapper *mw = newMatWithDims($SIZE(c),$SIZE(r),$PDL(in)->datatype,$SIZE(l),$P(in));
		if (!mw) $CROAK("newMatWithDims returned null.");
		cw_minMaxIdx(mw,&$min(),&$max());
		deleteMat(mw);
	'),
	);

sub ofunc {
    my ($func,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $codestr = pp_line_numbers __LINE__, sprintf <<'EOF', $func;
		MatWrapper *mw = newMatWithDims($SIZE(c),$SIZE(r),$PDL(in)->datatype,$SIZE(l),$P(in));
		if (!mw) $CROAK("newMatWithDims returned null.");
		$b() = cw_%s(mw);
		deleteMat(mw);
EOF
    pp_def($func,
	   Pars => 'in(l,c,r); [o]b()',
	   GenericTypes=>['N','D'],
	   NoPthread=>1,
	   PMCode => pp_line_numbers(__LINE__-1, qq{
		   sub $func {
			   my (\$self) = \@_;
			   my \$res=zeroes(ushort,1);
			   _${func}_int(\$self,\$res);
			   \$res;
		   }
	   },),
	   Code => $codestr,
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;

EOD
}

ofunc(@$_) for (
  ['rows',"returns rows of the Mat-wrapped ndarray"],
  ['cols',"returns cols of the Mat-wrapped ndarray"],
  ['channels',"returns channels of the Mat-wrapped ndarray"],
);

sub add_const {
  my ($args, $text) = @_;
  pp_add_exported($text);
  pp_addxs(<<EOF);
int $text(@{[@$args ? join(',',map qq{@$_}, @$args) : '']})
CODE:
 RETVAL = cw_const_$text(@{[join(',',map $_->[1], @$args)]});
OUTPUT:
 RETVAL

EOF
}

for my $bits (qw(8UC 8SC 16UC 16SC 32SC 32FC 64FC)) {
  add_const([], "CV_$bits$_") for 1..4;
  add_const([[qw(int n)]], "CV_$bits");
}

open my $consts, '<', 'constlist.txt' or die "constlist.txt: $!";
while (!eof $consts) {
  chomp(my $line = <$consts>);
  add_const([], $line);
};

pp_done();
