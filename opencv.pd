use strict;
pp_addpm ({At=>'Top'},<<'EOPM');
use 5.10.0;
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - This module interfaces perl/PDL and OpenCV.

=head1 SYNOPSIS

	use PDL::OpenCV;
	use PDL;
	use PDL::NiceSlice;

	...

	$mw->imshow();
	...
	$result=$mw->get_data;

=head1 Description

Use PDL::OpenCV to call OpenCV functions on your data using perl/PDL. This module
is the glue between the two tools. OpenCV nad perl's C++ interface are not
compatible, a C layer is introduced and needs to be built separately, see INSTALLATION.

=head1 Functions

=cut

use Data::Dumper;

sub PDL::OpenCV::get_dp {
	my ($self,$p) = @_;
	barf ("get_dp: not a piddle! ") unless (ref($p) =~ /PDL/ );
	getD($$self,$p);
	say "data ref ",$p->get_dataref;
	$p->upd_data;
	$p;
}

sub to_planes {
	my $m = shift;
	my ($c,$r,$l);
	my @d=$m->dims;
	$c=shift @d;
	$r=shift @d;
	$l=1;
	if ($m->ndims>2 && $c < 4) {
		$l=$c;
		$c=$r;
		$r=shift @d;
	}
	#$m->reshape($l,$c,$r,@d);
	$l,$c,$r,@d;
}

EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 Known issues

The number of functions in OpenCV is large, if you do not encounter what is needed,
there are fairly easy ways to create the wrappers. Look at ufunc/ofunc in opencv.pd
and gen_code in genwrap.pl. Please file a report if you do so.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
typedef MatWrapper matObj;
EOH
pp_addxs('','
MODULE = PDL::OpenCV PACKAGE = PDL::OpenCV

void * dataPtr (mo)
	matObj * mo
CODE:
	void * data_ptr = getData(mo);
	RETVAL = data_ptr;
OUTPUT:
RETVAL

matObj *
nMat (pid)
pdl * pid
CODE:
PDL_Indx l = pid->dims[0], c = pid->dims[1], r = pid->dims[2];
if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
RETVAL = newMat(c,r,pid->datatype,l,pid->data);
if (RETVAL==NULL) barf("newMat returned null.\n");
OUTPUT:
RETVAL

void
getD(mo, pid)
matObj *  mo
pdl * pid
CODE:
void * ptr =  mo;
matObj * mw =  ptr;
printf("getD mo. %p mw. %p data %p\n",mo,mw,getData(mw));
ptr =getData(mo);
float * fp = ptr;
pid->data=ptr;
printf("data (pid) 0,0 %f\n", fp[0]);

MODULE = PDL::OpenCV 		PACKAGE = matObjPtr PREFIX = mat_

void
mat_DESTROY(mw)
  matObj * mw
 CODE:
  deleteMat(mw);
  free (mw);

');

pp_def('create_video',
	Pars=>'m(l,c,r,f)',
	OtherPars=>'char *file; double fps; char *code',
	NoPthread=>1,
	GenericTypes=>[qw/A B S U L F D/ ],
	Code=>pp_line_numbers(__LINE__,'
	    if (!$COMP(file) || !strlen($COMP(file))) $CROAK("No file name given!");
	    broadcastloop %{
		MatWrapper *mw=emptyMW();
		int bs=PDL->howbig($PDL(m)->datatype);
		PDL_Indx sz = $SIZE(l)*$SIZE(c)*$SIZE(r)*bs;
		printf ("code %s\n",$COMP(code));
		printf ("frames %"IND_FLAG" ",$SIZE(f));
		printf ("cols %"IND_FLAG" ",$SIZE(c));
		printf ("rows %"IND_FLAG" ",$SIZE(r));
		printf ("planes %"IND_FLAG" ",$SIZE(l));
		printf ("datatype %d\n",bs);
		printf ("size %"IND_FLAG"\n",sz);
		int res = newVector(mw,$SIZE(f),$SIZE(c), $SIZE(r), bs, $SIZE(l), $P(m), sz);
		printf("code %s\n",$COMP(code));
		res = vWrite(mw,$COMP(file),$COMP(code),$COMP(fps));
		deleteMat(mw);
	    %}
	'),
	Doc=>'
=for ref

Stores a (colour,x,y,frame) ndarray in a file.

	$mo=create_video($piddle,file,fps,[code]);

For possible encodings see https://www.fourcc.org/codecs/. If not supplied, OpenCV will try to derive it from the file name.

From the OpenCV documentation:

=over

=item    With some backends fourcc=-1 pops up the codec selection dialog from the system.

=item    To save image sequence use a proper filename (eg. img_%02d.jpg) and fourcc=0 OR fps=0. Use uncompressed image format (eg. img_%02d.BMP) to save raw frames.

=item    Most codecs are lossy. If you want lossless video file you need to use a lossless codecs (eg. FFMPEG FFV1, Huffman HFYU, Lagarith LAGS, etc...)

=item    If FFMPEG is enabled, using codec=0; fps=0; you can create an uncompressed (raw) video file.

=back

=cut
',
);

pp_def('video_dims',
	Pars=>'[o] dims(n=5);',
	OtherPars=>'char * file',
	GenericTypes=>[qw/N/],
	NoPthread=>1,
	Code=>pp_line_numbers(__LINE__,'
		PDL_Indx t,l,c,r,f;
		const char *ret = vDims($COMP(file), &t, &l, &c, &r, &f);
		if (ret) $CROAK("Error in vDims: %s", ret);
		$dims(n=>0)=t;
		$dims(n=>1)=l;
		$dims(n=>2)=c;
		$dims(n=>3)=r;
		$dims(n=>4)=f;
	'),
);

pp_def('vread',
	Pars=>'[o] m(l,c,r,f);',
	OtherPars=>'char *file; int mattype; PDL_Indx ls; PDL_Indx cs; PDL_Indx rs; PDL_Indx fs',
	GenericTypes=>[qw/A B S U L F D/ ],
	NoPthread=>1,
	PMCode=>pp_line_numbers(__LINE__,'
		sub vread {
			my ($name,$p)=@_;
			$p=PDL->null unless UNIVERSAL::isa($p, "PDL");
			barf "cannot read file $name!" unless -f $name;
			_vread_int($p,$name,video_dims($name)->list);
			$p;
		}
		'
		),
	RedoDimsCode=>pp_line_numbers(__LINE__,'
		$SIZE(l)=$COMP(ls);
		$SIZE(c)=$COMP(cs);
		$SIZE(r)=$COMP(rs);
		$SIZE(f)=$COMP(fs);
		printf ("number of frames %"IND_FLAG"\n",$SIZE(f));
		printf ("data pointer %p\n",$P(m));
		printf ("vread: t=%d l=%"IND_FLAG" c=%"IND_FLAG" r=%"IND_FLAG"\n",$COMP(mattype),$SIZE(l),$SIZE(c),$SIZE(r));
		if ($PDL(m)->state & PDL_MYDIMS_TRANS)
		  $PDL(m)->datatype = get_pdltype($COMP(mattype));
		'),
	Code=>pp_line_numbers(__LINE__,'
		MatWrapper *mw=emptyMW();
		PDL_Indx f=vRead(mw,$COMP(file));
		if (f<=0) $CROAK("Failed to read video. %s.\n",$COMP(file));
		int found_datatype = getDataCopy(mw,$P(m),$SIZE(f));
		if (found_datatype != $PDL(m)->datatype)
		  $CROAK("Got wrong datatype %d, ndarray type=%d", found_datatype, $PDL(m)->datatype);
		deleteMat(mw);
	'),
);

pp_addpm(<<'EOF');
sub new_mat {
	my ($class,$m)=@_;
	my @d=to_planes($m);
	$m->make_physical;
	my $mw = nMat($m);
	bless $mw,$class;
}

=head2 new_mat - the constructor of a Mat() object.

From a piddle, a Mat is created. Note, that OpenCV is rows first. Colour planes
are derived from the first dimension, I think OpenCV defaults to BGR(A), please
checkout the OpenCV documentation. This is the basic constructor of the perl
OpenCV Mat object. Use this whenever you need to send data to OpenCV.


Only a subset of types is supported by OpenCV, see the docuemnation.

for stacks of images, use create_video.

=cut
EOF

pp_def ('get_data',
	Pars=>'[o] m(j,k,l);',
	OtherPars=>'MatWrapper * mw;',
	RedoDimsCode=>pp_line_numbers(__LINE__,
	'
		PDL_Indx js = $SIZE(j);
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		PDL_Indx ch = cw_channels($COMP(mw));
		PDL_Indx x = cols($COMP(mw));
		PDL_Indx y = rows($COMP(mw));
		//if (js > 3 && ks == y && js == x) {
			//$PDL(m)->ndims++;
			$SIZE(j)=ch;
			$SIZE(k)=x;
			$SIZE(l)=y;
		//}
		printf("ch %"IND_FLAG" j; %"IND_FLAG" x %"IND_FLAG" : k %"IND_FLAG" / y %"IND_FLAG" : l %"IND_FLAG"\n ",ch,$SIZE(j),x,$SIZE(k),y,$SIZE(l));
	'),
	Code=>pp_line_numbers(__LINE__,
	'
			//double * ptr =$P(m);
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
			printf ("data pointer %p\n",$P(m));
			int t=getDataCopy($COMP(mw),$P(m),1);
			printf ("get_data: type %d\n",t);
			$PDL(m)->datatype=t;
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
		printf ("get_data: data pointer %p\n",$P(m));
		PDL_Indx js = $SIZE(j);
			//$P(m)= ($PDL *) ptr;
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub get_data {
			my ($mw,$p,) = @_;
			my @d;
			unless (ref ($p) =~ "PDL") {
				$p=PDL->null;
			} else {
				#$p=$p->transpose;
				@d = to_planes($p);
				$p->reshape(@d);
			}
			$p->make_physical;
			#$p->upd_data;
			say "ref to data" ,$p->get_dataref;
			_get_data_int($p,$$mw);
			#say "data type ", $p->type;
			#say "(get_data) 4,4: ",$p->slice("4","4");
			#say "ref to data after " ,$p->get_dataref;
			#say "(get_data) 48,48: after",$p->slice("48","48");
			$p; #->transpose;
		}
		',),
	Doc=><<'EOD',

=head2 get_data - gets data from a Mat object into a piddle. If you use an exisitng piddle, size and type should match.
The first dimension are color planes. Be aware that OpenCV is rows first wheres PDL is columns first.

	my $image=$mw->get_data;

=cut
EOD

	);

pp_addpm(<<'EOPM');
sub data_ptr {
	my $mw=shift;
	dataPtr($$mw);
}

=head2 data_ptr - Returns the Mat.data pointer.

=cut

EOPM

pp_def('mat_type',
	Pars=>'[io] cvt(); [io] pt();',
	OtherPars=>'MatWrapper * mi; ',
	Code=>pp_line_numbers(__LINE__, q{
		//int * pt = & $COMP(pdltyp);
		int t,ct;
		t = $pt();
		ct = $cvt();
		//printf ("cvt %d pd %d \n",ct,t);
		ct = cwtype($COMP(mi),& t);
		//printf ("cvt %d pd %d \n",$cvt(),$pt());
		$pt()=t;
		$cvt()=ct;
	} ),
	PMCode=>pp_line_numbers(__LINE__, q{
		sub mat_type {
			my ($mw,$t) =@_;
			my $ct=pdl([-1]);
			$t=pdl([-1]) unless defined $t;
			#say $t->info,$ct->info;
			#say "t $t ct $ct";
			_mat_type_int($t,$ct,$$mw,);
			$t=sclr $t;
			$ct=sclr $ct;
			#say "type $t cvtype $ct";
			($t,$ct);
		}
	}
	),
	Doc=>'
=for ref

Returns the pdl data type number, as in $p->get_datatype, and the OpenCV data type of the Mat object.

	($pdltype,$cvtype)=$mw->mat_type();
',
	);

pp_def('cv_minmax',
	Pars => 'in(dim1,dim2,dim3); [o]m(k=4)',
	Code=>pp_line_numbers(__LINE__,'
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		if (l>1) $CROAK( "minMaxIdx only works on single channel (%d) arrays. \n",l);
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		double mymin;
		double mymax;
		//int * mil,mal;
		//printf("min %f max %f\n",mymin,mymax);
		cw_minMaxIdx(mw,& mymin,& mymax); //,mil,mal);
		deleteMat(mw);
		//printf("min %f max %f\n",mymin,mymax);
		$m(k=>0)=mymin;
		$m(k=>1)=mymax;
		//$m(k=>2)=mil;
		//$m(k=>3)=mal;
	'),
	);

sub protect_chars {
	my ($txt) = @_;
	$txt =~ s/>/E;gt#/g;
	$txt =~ s/</E;lt#/g;
	$txt =~ s/;/</g;
	$txt =~ s/#/>/g;
	return $txt;
}

sub ofunc {
    my ($name,$func,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $codestr = pp_line_numbers __LINE__, sprintf <<'EOF', $func;
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		$b() = %s(mw);
		deleteMat(mw);
EOF
    pp_def($name,
	   Pars => 'in(dim1,dim2,dim3); [o]b()',
	   GenericTypes=>['N','D'],
	   NoPthread=>1,
	   PMCode => pp_line_numbers(__LINE__-1, qq{
		   sub $name {
			   my (\$self) = \@_;
			   my \$res=zeroes(ushort,1);
			   _${name}_int(\$self,\$res);
			   \$res;
		   }
	   },),
	   Code => $codestr,
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.
EOD
}

# generate functions.
ofunc($_,$_,"returns $_ of the Mat object. \n") for qw/rows cols cw_channels/;

pp_done();
