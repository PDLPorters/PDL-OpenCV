use strict;
use warnings;

my $T = [qw(A B S U L F D)];

pp_addpm ({At=>'Top'},<<'EOPM');
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - PDL interface to OpenCV

=head1 SYNOPSIS

  use PDL::OpenCV::VideoCapture;
  use PDL::OpenCV::VideoWriter;
  my $vfile='t/Megamind.avi';
  my $vc = PDL::OpenCV::VideoCapture->new_uri($vfile);
  my $frame = $vc->read;
  my $writer = PDL::OpenCV::VideoWriter->new;
  $writer->open($outfile, 'MP4V', 20, (map $frame->dim($_), 1,2), 1);
  while (defined $frame) {
    $writer->write($frame);
  }

=head1 DESCRIPTION

Use PDL::OpenCV to call OpenCV functions on your data using Perl/PDL.

PDL data for this purpose must be dimensioned C<(channels,cols,rows)>
where C<channels> might be 1 if grayscale. This module will not use
heuristics to guess what you meant if you only supply 2-dimensional data.

As can be seen above, this distribution is structured to very closely
match the structure of OpenCV v4 itself. That means the submodules
match the "classes" and/or "modules" in OpenCV, with the obvious exception
of the C<Mat> class which needs special handling to thinly wrap ndarrays
going into and coming back from OpenCV.

This includes method/function names which are exactly the same
as in OpenCV, without being modified for the common Perl idiom
of snake_casing. This is intended to make the OpenCV documentation
trivially easy to use for the PDL binding (where a binding exists),
including available tutorials.

Where things do not work as you would expect from a PDL and/or OpenCV
point of view, and it is not documented as doing so, this is a bug -
please report it as shown at L</BUGS> below.

=cut
EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 BUGS

Please report bugs at L<https://github.com/PDLPorters/PDL-OpenCV/issues>,
or on the mailing list(s) at L<https://pdl.perl.org/?page=mailing-lists>.

=head1 AUTHOR

Ingo Schmid and the PDL Porters. Same terms as PDL itself.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
EOH

pp_def('minMaxIdx',
	Pars => 'in(l,c,r); double [o]min(); double [o]max()',
	Code=>pp_line_numbers(__LINE__,'
		if ($SIZE(l)>1) $CROAK( "minMaxIdx only works on single channel (got l=%"IND_FLAG") arrays.\n",$SIZE(l));
		MatWrapper *mw = newMatWithDims($SIZE(c),$SIZE(r),$PDL(in)->datatype,$SIZE(l),$P(in));
		if (!mw) $CROAK("newMatWithDims returned null.");
		cw_minMaxIdx(mw,&$min(),&$max());
		deleteMat(mw);
	'),
	);

sub ofunc {
    my ($class,$func,$doc,$ismethod,$ret,$opt,@params) = @_;
    die "No class given for method='$ismethod'" if !$class and $ismethod;
    $_ = '' for my ($initstr, $afterstr, $callprefix);
    my (@checks, @callargs, @pars, @otherpars, @returns, @pmpars);
    my $pcount = 1;
    for (@params) {
      my ($type, $var) = @$_;
      if ($type eq 'MatWrapper *') {
	push @pmpars, $var;
	push @pars, "$var(l$pcount,c$pcount,r$pcount)";
	$initstr .= "$type$var = newMatWithDims(\$SIZE(c$pcount),\$SIZE(r$pcount),\$PDL($var)->datatype,\$SIZE(l$pcount),\$P($var));\n";
	push @checks, qq{!$var};
	$afterstr .= "deleteMat($var);\n";
	push @callargs, $var;
	$pcount++;
      } else {
      }
    }
    if ($ret ne 'void') {
      push @pmpars, 'res';
      push @pars, "$ret [o] res()";
      push @returns, 'res';
      $callprefix = '$res() = ';
    }
    my $retstr = !@returns ? '' : "!wantarray ? \$$returns[-1] : (@{[join ',', map qq{\$$_}, @returns]})";
    my $codestr = join '',
      $initstr,
      (!@checks ? () : qq{if (@{[join ' || ', @checks]}) {\n$afterstr\n\$CROAK("Error during initialisation");\n}\n}),
      ${callprefix}.join('_', grep length,'cw',$class,$func)."(".join(',', @callargs).");\n",
      $afterstr;
    my $pmsetnull = join "\n", map "\$$_ = PDL->null if !defined \$$_;", @returns;
    pp_def($func,
	   Pars => join('; ', @pars),
	   OtherPars => join('; ', @otherpars),
	   GenericTypes=>$T,
	   NoPthread=>1,
	   PMCode => qq{
		   sub $func {
			   my (@{[join ',', map "\$$_", @pmpars]}) = \@_;
			   $pmsetnull
			   _${func}_int(@{[join ',', map "\$$_", @pmpars]});
			   $retstr
		   }
	   },
	   Code => $codestr,
	   Doc => "=for ref\n\n$doc",
    );
}

ofunc(@$_) for (
  ['Mat','rows',"returns rows of the Mat-wrapped ndarray",2,'int',{},['MatWrapper *','mw']],
  ['Mat','cols',"returns cols of the Mat-wrapped ndarray",2,'int',{},['MatWrapper *','mw']],
  ['Mat','channels',"returns channels of the Mat-wrapped ndarray",1,'int',{},['MatWrapper *','mw']],
);

sub add_const {
  my ($args, $text) = @_;
  pp_add_exported($text);
  pp_addxs(<<EOF);
int $text(@{[@$args ? join(',',map qq{@$_}, @$args) : '']})
CODE:
 RETVAL = cw_const_$text(@{[join(',',map $_->[1], @$args)]});
OUTPUT:
 RETVAL

EOF
}

for my $bits (qw(8UC 8SC 16UC 16SC 32SC 32FC 64FC)) {
  add_const([], "CV_$bits$_") for 1..4;
  add_const([[qw(int n)]], "CV_$bits");
}

open my $consts, '<', 'constlist.txt' or die "constlist.txt: $!";
while (!eof $consts) {
  chomp(my $line = <$consts>);
  add_const([], $line);
}

pp_done();
