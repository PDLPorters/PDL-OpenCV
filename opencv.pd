use strict;
use warnings;

my $T = [qw(A B S U L F D)];

pp_addpm ({At=>'Top'},<<'EOPM');
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - PDL interface to OpenCV

=head1 SYNOPSIS

  use PDL::OpenCV::VideoCapture;
  use PDL::OpenCV::VideoWriter;
  my $vfile='t/Megamind.avi';
  my $vc = PDL::OpenCV::VideoCapture->new;
  $vc->open($vfile);
  my $frame = $vc->read;
  my $writer = PDL::OpenCV::VideoWriter->new;
  $writer->open($outfile, 'MP4V', 20, (map $frame->dim($_), 1,2), 1);
  while (defined $frame) {
    $writer->write($frame);
    # and/or display it, or feed it to a Tracker, or...
  }

=head1 DESCRIPTION

Use PDL::OpenCV to call OpenCV functions on your data using Perl/PDL.

As can be seen above, this distribution is structured to very closely
match the structure of OpenCV v4 itself. That means the submodules
match the "classes" and/or "modules" in OpenCV, with the obvious exception
of the C<Mat> class which needs special handling to thinly wrap ndarrays
going into and coming back from OpenCV.

This includes method/function names which are exactly the same
as in OpenCV, without being modified for the common Perl idiom
of snake_casing. This is intended to make the OpenCV documentation
trivially easy to use for the PDL binding (where a binding exists),
including available tutorials.

Where things do not work as you would expect from a PDL and/or OpenCV
point of view, and it is not documented as doing so, this is a bug -
please report it as shown at L</BUGS> below.

=head1 IMAGE FORMATS

In PDL, images are often C<byte,3,x,y> or occasionally (e.g. in
L<PDL::Graphics::Simple>) C<byte,x,y,3>. The 3 is always R,G,B. Sometimes
4 is supported, in which case the 4th column will be an alpha
(transparency) channel, or 1, which means the image is grayscale.

OpenCV has the concepts of "depth" and "channels".

"Channels" resembles the above 1/3/4 point, with the important caveat
that the default for OpenCV image-reading is to format data not as R,G,B,
but B,G,R. This is for historical reasons, being the format returned by
the cameras first used at the start of OpenCV. Use C<cvtColor> is your
application requires otherwise.

"Depth" is bit-depth (and data type) per pixel and per channel: the
bit-depth will be a multiple of 8, and the data type will be integer
(signed or unsigned) or floating-point.

PDL data for use with OpenCV must be dimensioned C<(channels,x,y)>
where C<channels> might be 1 if grayscale. This module will not use
heuristics to guess what you meant if you only supply 2-dimensional data.

=cut
EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 BUGS

Please report bugs at L<https://github.com/PDLPorters/PDL-OpenCV/issues>,
or on the mailing list(s) at L<https://pdl.perl.org/?page=mailing-lists>.

=head1 AUTHOR

Ingo Schmid and the PDL Porters. Same terms as PDL itself.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
EOH

sub ofunc {
    my ($class,$func,$doc,$ismethod,$ret,$opt,@params) = @_;
    die "No class given for method='$ismethod'" if !$class and $ismethod;
    $_ = '' for my ($initstr, $afterstr, $callprefix);
    my (@checks, @callargs, @pars, @otherpars, @returns, @pmpars);
    my $pcount = 1;
    for (@params) {
      my ($type, $var) = @$_;
      push @pmpars, $var;
      if ($type eq 'MatWrapper *') {
	push @pars, "$var(l$pcount,c$pcount,r$pcount)";
	$initstr .= "$type$var = cw_Mat_newWithDims(\$SIZE(l$pcount),\$SIZE(c$pcount),\$SIZE(r$pcount),\$PDL($var)->datatype,\$P($var));\n";
	push @checks, qq{!$var};
	$afterstr .= "cw_Mat_DESTROY($var);\n";
	push @callargs, $var;
	$pcount++;
      } else {
	(my $rawtype = $type) =~ s#\s*\*$##;
	push @pars, "$rawtype ".($rawtype ne $type ? '[o]' : '')."$var()";
	push @callargs, ($type =~ /\*$/ ? '&' : '') . "\$$var()";
	push @returns, $var;
      }
    }
    if ($ret ne 'void') {
      push @pmpars, 'res';
      push @pars, "$ret [o] res()";
      push @returns, 'res';
      $callprefix = '$res() = ';
    }
    my $retstr = !@returns ? '' : "!wantarray ? \$$returns[-1] : (@{[join ',', map qq{\$$_}, @returns]})";
    my $codestr = join '',
      $initstr,
      (!@checks ? () : qq{if (@{[join ' || ', @checks]}) {\n$afterstr\n\$CROAK("Error during initialisation");\n}\n}),
      ${callprefix}.join('_', grep length,'cw',$class,$func)."(".join(',', @callargs).");\n",
      $afterstr;
    my $pmsetnull = join "\n", map "\$$_ = PDL->null if !defined \$$_;", @returns;
    pp_def($func,
	   Pars => join('; ', @pars),
	   OtherPars => join('; ', @otherpars),
	   GenericTypes=>$T,
	   NoPthread=>1,
	   PMCode => qq{
		   sub $func {
			   my (@{[join ',', map "\$$_", @pmpars]}) = \@_;
			   $pmsetnull
			   _${func}_int(@{[join ',', map "\$$_", @pmpars]});
			   $retstr
		   }
	   },
	   Code => $codestr,
	   Doc => "=for ref\n\n$doc",
    );
}

ofunc(@$_) for (
  ['Mat','rows',"returns rows of the Mat-wrapped ndarray",2,'int',{},['MatWrapper *','mw']],
  ['Mat','cols',"returns cols of the Mat-wrapped ndarray",2,'int',{},['MatWrapper *','mw']],
  ['Mat','channels',"returns channels of the Mat-wrapped ndarray",1,'int',{},['MatWrapper *','mw']],
  ['','minMaxIdx',"returns minimum and maximum values of Mat-wrapped ndarray",0,'void',{},['MatWrapper *','mw'],["double *","min"],["double *","max"]],
);

sub add_const {
  my ($args, $text) = @_;
  pp_add_exported($text);
  pp_addxs(<<EOF);
MODULE = PDL::OpenCV PACKAGE = PDL::OpenCV PREFIX=cw_const_

int cw_const_$text(@{[@$args ? join(',',map qq{@$_}, @$args) : '']})
EOF
}

for my $bits (qw(8UC 8SC 16UC 16SC 32SC 32FC 64FC)) {
  add_const([], "CV_$bits$_") for 1..4;
  add_const([[qw(int n)]], "CV_$bits");
}

open my $consts, '<', 'constlist.txt' or die "constlist.txt: $!";
while (!eof $consts) {
  chomp(my $line = <$consts>);
  add_const([], $line);
}

pp_done();
