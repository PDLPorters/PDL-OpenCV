use strict;
pp_addpm ({At=>'Top'},<<'EOPM');
use 5.10.0;
use strict;
use warnings;

=head1 NAME

PDL::OpenCV - This module interfaces perl/PDL and OpenCV.

=head1 SYNOPSIS

	use PDL::OpenCV;
	use PDL;
	use PDL::NiceSlice;

	...

	$mw->imshow();
	...
	$result=$mw->get_data;

=head1 Description

Use PDL::OpenCV to call OpenCV functions on your data using perl/PDL. This module
is the glue between the two tools. OpenCV nad perl's C++ interface are not
compatible, a C layer is introduced and needs to be built separately, see INSTALLATION.

=head1 Functions

=cut

use Data::Dumper;

sub PDL::OpenCV::get_dp {
	my ($self,$p) = @_;
	barf ("get_dp: not a piddle! ") unless (ref($p) =~ /PDL/ );
	getD($$self,$p);
	say "data ref ",$p->get_dataref;
	$p->upd_data;
	$p;
}

sub to_planes {
	my $m = shift;
	my ($c,$r,$l);
	my @d=$m->dims;
	$c=shift @d;
	$r=shift @d;
	$l=1;
	if ($m->ndims>2 && $c < 4) {
		$l=$c;
		$c=$r;
		$r=shift @d;
	}
	#$m->reshape($l,$c,$r,@d);
	$l,$c,$r,@d;
}

EOPM

pp_addpm ({At=>'Bot'},<<'EOPM');
=head1 Known issues

The number of functions in OpenCV is large, if you do not encounter what is needed,
there are fairly easy ways to create the wrappers. Look at ufunc/ofunc in opencv.pd
and gen_code in genwrap.pl. Please file a report if you do so.

=cut
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless("PDL::OpenCV");

pp_addhdr << 'EOH';
#include "opencv_wrapper.h"
EOH

pp_def('create_video',
	Pars=>'[phys]m(l,c,r,f)',
	OtherPars=>'char *file; double fps; char *code',
	NoPthread=>1,
	GenericTypes=>[qw/A B S U L F D/ ],
	Code=>pp_line_numbers(__LINE__, <<'EOF'),
	    if (!$COMP(file) || !strlen($COMP(file))) $CROAK("No file name given!");
	    VideoWriterWrapper *vw = newVideoWriter();
	    const char *ret = openVideoWriter(vw, $COMP(file), $COMP(code), $COMP(fps), $SIZE(c), $SIZE(r), $SIZE(l) > 1);
	    if (ret) {
	      deleteVideoWriter(vw);
	      $CROAK("Error in openVideoWriter: %s", ret);
	    }
	    pdl *pid = $PDL(m);
	    broadcastloop %{
		loop (f) %{
		  MatWrapper *mw = newMat($SIZE(c),$SIZE(r),pid->datatype,$SIZE(l),&$m(l=>0,c=>0,r=>0));
		  if (!mw) $CROAK("newMat returned null.");
		  writeVideoWriter(vw, mw);
		  deleteMat(mw);
		%}
	    %}
	    deleteVideoWriter(vw);
EOF
	Doc=>'
=for ref

Stores a (colour,x,y,frame) ndarray in a file.

	$mo=create_video($piddle,file,fps,[code]);

For possible encodings see https://www.fourcc.org/codecs/. If not supplied, OpenCV will try to derive it from the file name.

From the OpenCV documentation:

=over

=item    With some backends fourcc=-1 pops up the codec selection dialog from the system.

=item    To save image sequence use a proper filename (eg. img_%02d.jpg) and fourcc=0 OR fps=0. Use uncompressed image format (eg. img_%02d.BMP) to save raw frames.

=item    Most codecs are lossy. If you want lossless video file you need to use a lossless codecs (eg. FFMPEG FFV1, Huffman HFYU, Lagarith LAGS, etc...)

=item    If FFMPEG is enabled, using codec=0; fps=0; you can create an uncompressed (raw) video file.

=back

=cut
',
);

pp_def('video_dims',
	Pars=>'[o] dims(n=5);',
	OtherPars=>'char * file',
	GenericTypes=>[qw/N/],
	NoPthread=>1,
	Code=>pp_line_numbers(__LINE__,'
		PDL_Indx t,l,c,r,f;
		VideoCaptureWrapper *cw = newVideoCapture();
		const char *ret = openVideoCaptureURI(cw, $COMP(file));
		if (ret) {
		  deleteVideoCapture(cw);
		  $CROAK("Error in openVideoCaptureURI: %s", ret);
		}
		ret = vDims(cw, &t, &l, &c, &r, &f);
		deleteVideoCapture(cw);
		if (ret) $CROAK("Error in vDims: %s", ret);
		$dims(n=>0)=t;
		$dims(n=>1)=l;
		$dims(n=>2)=c;
		$dims(n=>3)=r;
		$dims(n=>4)=f;
	'),
);

pp_def('vread',
	Pars=>'[o] m(l,c,r,f);',
	OtherPars=>'char *file; int mattype; PDL_Indx ls; PDL_Indx cs; PDL_Indx rs; PDL_Indx fs',
	GenericTypes=>[qw/A B S U L F D/ ],
	NoPthread=>1,
	PMCode=>pp_line_numbers(__LINE__,'
		sub vread {
			my ($name,$p)=@_;
			$p=PDL->null unless UNIVERSAL::isa($p, "PDL");
			barf "cannot read file $name!" unless -f $name;
			_vread_int($p,$name,video_dims($name)->list);
			$p;
		}
		'
		),
	RedoDimsCode=>pp_line_numbers(__LINE__,'
		$SIZE(l)=$COMP(ls);
		$SIZE(c)=$COMP(cs);
		$SIZE(r)=$COMP(rs);
		$SIZE(f)=$COMP(fs);
		printf ("number of frames %"IND_FLAG"\n",$SIZE(f));
		printf ("data pointer %p\n",$P(m));
		printf ("vread: t=%d l=%"IND_FLAG" c=%"IND_FLAG" r=%"IND_FLAG"\n",$COMP(mattype),$SIZE(l),$SIZE(c),$SIZE(r));
		if ($PDL(m)->state & PDL_MYDIMS_TRANS)
		  $PDL(m)->datatype = get_pdltype($COMP(mattype));
		'),
	Code=>pp_line_numbers(__LINE__,'
		VideoCaptureWrapper *cw = newVideoCapture();
		const char *ret = openVideoCaptureURI(cw, $COMP(file));
		if (ret) {
		  deleteVideoCapture(cw);
		  $CROAK("Error in openVideoCaptureURI: %s", ret);
		}
		MatWrapper *mw=emptyMW();
		PDL_Indx f;
		ret = vRead(mw,cw,&f);
		deleteVideoCapture(cw);
		if (ret) {
		  deleteMat(mw);
		  $CROAK("Failed to read video \'%s\': %s\n",$COMP(file),ret);
		}
		int found_datatype = getDataCopy(mw,$P(m),$SIZE(f));
		if (found_datatype != $PDL(m)->datatype)
		  $CROAK("Got wrong datatype %d, ndarray type=%d", found_datatype, $PDL(m)->datatype);
		deleteMat(mw);
	'),
);

pp_def('cv_minmax',
	Pars => 'in(dim1,dim2,dim3); [o]m(k=4)',
	Code=>pp_line_numbers(__LINE__,'
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		if (l>1) $CROAK( "minMaxIdx only works on single channel (%d) arrays. \n",l);
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		double mymin;
		double mymax;
		//int * mil,mal;
		//printf("min %f max %f\n",mymin,mymax);
		cw_minMaxIdx(mw,& mymin,& mymax); //,mil,mal);
		deleteMat(mw);
		//printf("min %f max %f\n",mymin,mymax);
		$m(k=>0)=mymin;
		$m(k=>1)=mymax;
		//$m(k=>2)=mil;
		//$m(k=>3)=mal;
	'),
	);

sub protect_chars {
	my ($txt) = @_;
	$txt =~ s/>/E;gt#/g;
	$txt =~ s/</E;lt#/g;
	$txt =~ s/;/</g;
	$txt =~ s/#/>/g;
	return $txt;
}

sub ofunc {
    my ($name,$func,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $codestr = pp_line_numbers __LINE__, sprintf <<'EOF', $func;
		pdl *pid = $PDL(in);
		PDL_Indx l = $SIZE(dim1), c = $SIZE(dim2), r = $SIZE(dim3);
		if (!(pid->ndims > 2 && l<4)) r=c, c=l, l=1;
		MatWrapper *mw = newMat(c,r,pid->datatype,l,$P(in));
		if (!mw) $CROAK("newMat returned null.");
		$b() = %s(mw);
		deleteMat(mw);
EOF
    pp_def($name,
	   Pars => 'in(dim1,dim2,dim3); [o]b()',
	   GenericTypes=>['N','D'],
	   NoPthread=>1,
	   PMCode => pp_line_numbers(__LINE__-1, qq{
		   sub $name {
			   my (\$self) = \@_;
			   my \$res=zeroes(ushort,1);
			   _${name}_int(\$self,\$res);
			   \$res;
		   }
	   },),
	   Code => $codestr,
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.
EOD
}

# generate functions.
ofunc($_,$_,"returns $_ of the Mat object. \n") for qw/rows cols cw_channels/;

pp_done();
