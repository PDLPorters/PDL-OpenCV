#!perl

use strict;
pp_addpm ({At=>'Top'},<<'EOPM');

use 5.10.0;


use Data::Dumper;

sub PDL::OpenCV::get_dp {
	my ($self,$p) = @_;
	barf ("get_dp: not a piddle! ") unless (ref($p) =~ /PDL/ );
	getD($$self,$p);
	say "data ref ",$p->get_dataref;
	$p->upd_data;
	$p;
}

sub to_planes {
	my $m = shift;
	my ($c,$r,$l);
	my @d=$m->dims;
	$c=shift @d;
	$r=shift @d;
	$l=1;
	if ($m->ndims>2 && $c < 4) {
		$l=$c;
		$c=$r;
		$r=shift @d;
	}
	#$m->reshape($l,$c,$r,@d);
	$l,$c,$r,@d;
}

EOPM
our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless ("PDL::OpenCV");

pp_addhdr << 'EOH';
 	#include "opencv_wrapper.h"
 	#include "generated_cvwrapper.h"
	// typedef TrackerWrapper trackerObj;
	typedef MatWrapper matObj;
	//MatWrapper * mw;

EOH
pp_addxs('','
MODULE = PDL::OpenCV PACKAGE = PDL::OpenCV

void * dataPtr (mo)
	matObj * mo
CODE:
	void * data_ptr = getData(mo);
	RETVAL = data_ptr;
OUTPUT: 
RETVAL


matObj *
newMW ()
 CODE:
matObj * mo= NULL;
mo=emptyMW();
if (mo==NULL) {
	barf("emptyMat returned null.\n");
}
  RETVAL = mo;
 OUTPUT:
  RETVAL


matObj *
nMat (p)
SV * p
CODE:
int t;
PDL_Indx c;
PDL_Indx r;
int l;
matObj * mo = NULL;
//char * type = SvRV( t );
pdl * pid = PDL->SvPDLV(p);
l = pid->dims[0];
c = pid->dims[1];
r = pid->dims[2];
void * ptr =  pid->data ;
t=pid->datatype;
printf ("type %d\n",t );
if (pid->ndims > 2 && l<4)  {
	mo=newMat(c,r,t,l,ptr);
} else {
	r=c;
	c=l;
	l=1;
	mo=newMat(c,r,t,1,ptr);
}
printf("cols %d rows %d type %d planes l %d ptr %p \n",c,r,t,l,ptr);
if (mo==NULL) {
	barf("newMat returned null.\n");
}
//printf ("newM: mo %p\n",mo);
//printf ("newM: data %p\n",getData(mo));
RETVAL = mo;
OUTPUT:
RETVAL


void  
getD(mo, p)
matObj *  mo
SV * p
CODE:
//mw = SvR
void * ptr =  mo;
matObj * mw =  ptr;
//printf ("getD *mo. %p\n",(*mo));
printf ("getD mo. %p\n",(mo));
printf ("getD mw. %p\n",mw);
pdl * pid = PDL->SvPDLV(p);
//MatAt(mw,4,4);
printf ("getD data %p\n",getData(mw));
ptr =getData(mo);
float * fp = ptr;
pid->data=ptr;
printf("data (pid) 0,0 %f\n", fp[0]);

MODULE = PDL::OpenCV 		PACKAGE = matObjPtr PREFIX = mat_


void
mat_DESTROY(mw)
  matObj * mw
 CODE:
  deleteMat(mw);
  free (mw);


');

pp_def('vector_size',
	Pars=>'indx [o] vs();',
	OtherPars=>'MatWrapper * mw;PDL_Indx s',
	PMCode=>pp_line_numbers(__LINE__,'
		sub vector_size {
			my ($mw,$size) = @_;
			$size = -1 unless $size>=0;
			my $p=PDL->null;
			_vector_size_int($p,$$mw,$size);
			$p;
		}
	'),
	Code=>pp_line_numbers(__LINE__,'
		$vs()=vectorSize($COMP(mw),$COMP(s));
	'),
);

pp_def('create_video',
	Pars=>'m(l,c,r,f)',
	OtherPars=>'MatWrapper * mw; int bs',
	GenericTypes=>[qw/A B S U L F D/ ],
	PMCode=>pp_line_numbers(__LINE__,'
		sub vread {
			my ($mo,$p)=@_;
			if (ref $mo ne q/PDL::OpenCV/) {
				$p=$mo;
				$mo=PDL::OpenCV::newMW();
				bless($mo,"PDL::OpenCV");
			}
			barf "No input piddle!\n" unless (ref ($p) =~ "PDL") ;
			$size=howbig($p->type);
			_create_video_int($p,$mo,$size);
		}
	'),
	Code=>pp_line_numbers(__LINE__,'
		PDL_Indx sz = $SIZE(l)*$SIZE(c)*$SIZE(r)*$COMP(bs);
		int res = newVector($COMP(mw),$SIZE(f),$SIZE(c), $SIZE(r) , $PDL(m)->datatype, $SIZE(l), $P(m), sz);

	'),
);

pp_def('vread', 
	Pars=>'m(l,c,r,f);',
	OtherPars=>'MatWrapper * mw; char * file',
	GenericTypes=>[qw/A B S U L F D/ ],
	PMCode=>pp_line_numbers(__LINE__,'
		sub vread {
			my ($mw,$name,$p)=@_;
			unless (ref ($p) =~ "PDL") {
				#say "rows ",$mw->rows;
				$p=PDL->null;
				#$p=zeroes(sclr ($mw->cols),sclr ($mw->rows),$mw->vector_size();
			}
			barf "cannot read file!" unless (-f $name);
			$p->make_physical;
			_vread_int($p,$$mw,$name);
			$p;
		}
		'
		),
	Code=>pp_line_numbers(__LINE__,'
		$PDL(m)->datatype=getDataCopy($COMP(mw),$P(m),$SIZE(f));
		if ($SIZE(f)<=0) {barf ("Failed to read video. %s.\n",$COMP(file));}
	'),
	RedoDimsCode=>pp_line_numbers(__LINE__,'
		$SIZE(c)=cols($COMP(mw),-1);
		$SIZE(r)=rows($COMP(mw),-1);
		$SIZE(f)=vread($COMP(mw),$COMP(file),$P(m));
		'),
		);

pp_def('new_mat',
	Pars=>'m(c,r);',
	GenericTypes=>[qw/A B S U L F D/ ],
	OtherPars=>'MatWrapper * mwi',
	Code=>pp_line_numbers(__LINE__,'
		//setData($COMP(mwi),$P(m),0);
		//printf ("after setData %f \n",MatAt($COMP(mwi),0,0));
		//printf ("after setData %f \n",$m(c=>0,r=>0));
		//printf ("data pointer %p \n",$P(m));
	'),
	PMCode=>pp_line_numbers(__LINE__,'
	sub new_mat{
		my ($class,$m)=@_;
		#$m->sever;
		#say "type ",$m->type,", ",$m->get_datatype;
		my @d=to_planes($m);
		my $mw = nMat($m); #,$m->get_dataref);
		bless $mw,$class;
		#_new_mat_int($m,$$mw);
		$mw;
	}',),
	Doc=><<"EOD",

=head2 new_mat - the constructor of a Mat() object.

From a 2-D piddle, a Mat is created. Note, that rows and cols are swapped.

EOD

);


pp_def ('get_data',
	Pars=>'[o] m(j,k,l);',
	OtherPars=>'MatWrapper * mw;',
	RedoDimsCode=>pp_line_numbers(__LINE__,
	'
		PDL_Indx js = $SIZE(j);
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		PDL_Indx ch = cw_channels($COMP(mw));
		PDL_Indx x = cols($COMP(mw),-1);
		PDL_Indx y = rows($COMP(mw),-1);
		//if (js > 3 && ks == y && js == x) { 
			//$PDL(m)->ndims++;
			$SIZE(j)=ch;
			$SIZE(k)=x;
			$SIZE(l)=y;
		//}
		printf ("ch %d j; %d x %d : k %d / y %d : l %d\n ",ch,$SIZE(j),x,$SIZE(k),y,$SIZE(l));
		/*if (ch == $SIZE(j)  && x == $SIZE(k) && y == $SIZE(l) )
		{
		} else {
			$CROAK("Matrix size does not match!\n");
		}
		*/
	'),
	Code=>pp_line_numbers(__LINE__,
	'
			//double * ptr =$P(m);
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
			int t=getDataCopy($COMP(mw),$P(m),1); 
			printf ("get_data: type %d\n",t);
			$PDL(m)->datatype=t;
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
			//$P(m)= ($PDL *) ptr;
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub get_data {
			my ($mw,$p,) = @_;
			my @d;
			unless (ref ($p) =~ "PDL") {
				#say "rows ",$mw->rows;
				#$p=zeroes(sclr $mw->cw_channels ,sclr ($mw->cols),sclr ($mw->rows));
				$p=PDL->null;
			} else {
				#$p=$p->transpose;
				@d = to_planes($p);
				$p->reshape(@d);
			}
			$p->make_physical;
			#$p->upd_data;
			say "ref to data" ,$p->get_dataref;
			_get_data_int($p,$$mw);
			#say "data type ", $p->type;
			#say "(get_data) 4,4: ",$p->slice("4","4");
			#say "ref to data after " ,$p->get_dataref;
			#say "(get_data) 48,48: after",$p->slice("48","48");
			$p; #->transpose;
		}
		',),
	Doc=><<"EOD",

=head2 get_data - update data from a Mat object. Size and type should match.

EOD

	);


pp_def ('set_data',
	Pars=>'m(k,l);',
	OtherPars=>'MatWrapper * mw',
	GenericTypes=>[qw/A B S U L F D/ ],
	Code=>pp_line_numbers(__LINE__,
	'
			printf("m(3,1) %f \n",$m(k=>0,l=>0));
			setData($COMP(mw),$P(m),$PDL(m)->datatype);
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub set_data {
			my ($mw,$data) = @_;
			warn "This sets the Mat data pointer to the piddles. Apparently, this is unstable. Better use new_mat!\n";
			barf "no data supplied.\n" unless defined $data;
			barf "data has wrong dimensions.\n" unless ($data->dim(1) == $mw->rows &&  $mw->cols==$data->dim(0));
			$data->make_physical;
			_set_data_int(pdl($data),$$mw);
		}
	'),
	Doc=><<"EOD",

=head2 set_data - update data of a Mat object. Size and type should match.

EOD

	);




pp_add_boot (<< 'EOB');

	cv_init();
	//printf ("init done (autoinclude)\n");


EOB

pp_addpm(<<'EOPM');

sub data_ptr {
	my $mw=shift;
	dataPtr($$mw);
}

sub mat2pdl {
	my ($mw) = @_;
	my $p=PDL->new;
	$p->set_datatype($PDL_F);
	$p->setdims( [$mw->cols,$mw->rows]);
	my $dp=$p->get_dataref(data_ptr($mw));
	$p->upd_data;
}
EOPM

pp_def ('mat_at',
	Pars=>'double [o] m(j);',
	OtherPars=>'MatWrapper * mwi;int x;int y;',
	Code=>pp_line_numbers(__LINE__,
	'
		//printf ("Hello Mat!\n");
		//cwtype ( $COMP(mwi), pdltype);
		$PDL(m)->datatype= MatAt($COMP(mwi),$COMP(x),$COMP(y),$P(m));
		

		//printf ("mat_at: pointer %p\n",$P(m));
		//printf ("mat_at: data type %d\n",$PDL(m)->datatype);
		//printf ("mat_at: %f\n",$P(m)[0]);
		//$P(m)=vec;
		/*
		loop(j) %{ 
			$m()=frame.data[cw_channels($COMP(mwi))*(cols($COMP(mwi)*$COMP(y) + $COMP(x)) + j];
		%}
		*/
	',),
	PMCode=>pp_line_numbers(__LINE__,
	q{
	sub mat_at {
		my ($mw,$x,$y)=@_;
		my ($t,$ct) = $mw->type;
		my $o=zeroes(sclr $mw->cw_channels);
		#say "pointer $$mw";
		_mat_at_int($o,$$mw,$x,$y);
		#say "mat_at value $o";
		$o;
	}
	},
	),
);

pp_def('convertTo',
	Pars=>'',
	OtherPars=>'MatWrapper * mi; MatWrapper * mo; int type',
	PMCode=>pp_line_numbers(__LINE__,
<<'EOPM'),
		sub convertTo {
		my ($mi,$mo,$t) = @_;
		if (ref $mo ne q/PDL::OpenCV/) {
			$t=$mo if defined $mo;
			$mo=PDL::OpenCV::newMW();
			bless($mo,'PDL::OpenCV');
		}
		barf "Not a valid data type $t\n" unless defined $t;
		_convertTo_int($$mi,$$mo,$t);
		$mo;
	}
EOPM

	Code=>pp_line_numbers(__LINE__,
		'cw_convertTo($COMP(mi),$COMP(mo),$COMP(type)); '),
	);

pp_def('type',
	Pars=>'[io] cvt(); [io] pt();',
	OtherPars=>'MatWrapper * mi; ',
	Code=>pp_line_numbers(__LINE__, q{
		//int * pt = & $COMP(pdltyp);
		int t,ct;
		t = $pt();
		ct = $cvt();
		//printf ("cvt %d pd %d \n",ct,t);
		ct = cwtype($COMP(mi),& t);
		//printf ("cvt %d pd %d \n",$cvt(),$pt());
		$pt()=t;
		$cvt()=ct;
	} ),
	PMCode=>pp_line_numbers(__LINE__, q{
		sub type {
			my ($mw,$t) =@_;
			my $ct=pdl([-1]);
			$t=pdl([-1]) unless defined $t;
			#say $t->info,$ct->info;
			#say "t $t ct $ct";
			_type_int($t,$ct,$$mw,);
			$t=sclr $t;
			$ct=sclr $ct;
			#say "type $t cvtype $ct";
			($t,$ct);
		}
	}
	),
	);

sub protect_chars {
	my ($txt) = @_;
	$txt =~ s/>/E;gt#/g;
	$txt =~ s/</E;lt#/g;
	$txt =~ s/;/</g;
	$txt =~ s/#/>/g;
	return $txt;
}





sub ofunc {
    my ($name,$func,$overload,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $got_complex = PDL::Core::Dev::got_complex_version($func, 0);
    # handle exceptions
    my $badcode; # = '$ISBAD(a())';
    if ( exists $extra{Exception} ) {
#	$badcode .= " || $extra{Exception}";
#	print "Warning: ignored exception for $name\n";
	# NOTE This option is unused ($badcode is commented out above).
	#      See also `biop()`.
	delete $extra{Exception};
    }
    my $codestr = '
		//printf ("ofunc: mw %p\n",$COMP(mw)); 
		int res;
		res = '.$func.'($COMP(mw));
		//printf ("res %d\n",res);
		$b() = res;' ;
    pp_def($name,
	   Pars => '[o]b()',
	   OtherPars=>'MatWrapper * mw; ',
	   GenericTypes=>['N','D'],
	   PMCode => pp_line_numbers(__LINE__, qq{
		   sub $name {
			   my (\$self) = \@\_;
			   my \$res=zeroes(ushort,1);
			   _$name\_int(\$res,\$\$self,);
			   #say "res \$res?";
			   \$res;
		   }
	   },),
	   Code => pp_line_numbers(__LINE__, qq{
	           $codestr
	   }),
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov () ;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.

=cut

EOD
} # sub: ufunc()

sub ufunc {
    my ($name,$func,$overload,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $got_complex = PDL::Core::Dev::got_complex_version($func, 1);
    # handle exceptions
    my $badcode; # = '$ISBAD(a())';
    if ( exists $extra{Exception} ) {
#	$badcode .= " || $extra{Exception}";
#	print "Warning: ignored exception for $name\n";
	# NOTE This option is unused ($badcode is commented out above).
	#      See also `biop()`.
	delete $extra{Exception};
    }
    my $codestr = '
		//printf ("ufunc: mw %p\n",$COMP(mw)); 
		int res;
		res = '.$func.'($COMP(mw),$COMP(v));
		//printf ("res %d\n",res);
		$b() = res;' ;
    pp_def($name,
	   Pars => '[o]b()',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	   GenericTypes=>['N'],
	   PMCode => pp_line_numbers(__LINE__, qq{
		   sub $name {
			   my (\$self,\$v) = \@\_;
			   \$v = -1 unless defined \$v;
			   my \$res=zeroes(ushort,1);
			   #say "$name calling now (\$v)";
			   _$name\_int(\$res,\$\$self,\$v);
			   #say "res \$res?";
			   \$res;
		   }
	   },),
	   Code => pp_line_numbers(__LINE__, qq{
	           $codestr
	   }),
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.

=cut

EOD
} # sub: ufunc()

# generate functions.
map {ufunc($_,$_,0,"returns and optionally sets $_ of matrix. \n");} (qw/rows cols / );
map {ofunc($_,$_,0,"returns and optionally sets $_ of matrix. \n");} (qw/cw_channels planes/ );


pp_done();


__END__
use Inline C => Config =>
           enable => autowrap => LIBS => "-lopencv_wrapper" ;
 
use Inline C =>"#include <generated_cvwrapper.h>
int cw_convertTo ( MatWrapper * mw ,  MatWrapper * out, int type) ;
";

pp_def('cols2',
	Pars=>'[o] c();',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	GenericTypes=>['U'],
	Code=>'
		printf("cols2: (c) v: %d\n",$COMP(v));
		printf("cols2: (c) mw: %p\n",$COMP(mw));
		int r= cols($COMP(mw),$COMP(v));
		printf("cols2: (c) r: %d\n",r);
		$c()=r;',

	PMCode=>'   sub cols2 {
			   my ($self,$v) = @_;
			   $v = -1 unless defined $v;
			   my $res=zeroes(ushort,1);
			   say "cols2 calling now ($v)";
			   say "cols2 calling self ($$self)";
			   _cols2_int($res,$$self,$v);
			   say "res $res?";
			   $res;
		   }
	'
	);

pp_addxs('','
matObj *
newM (c,r,t)
        int c
        int r
        int t
 CODE:
matObj * mo = NULL;
 t=cvT.f32c1;
 mo=emptyMat(c,r,t);
 if (mo==NULL) {
         barf("emptyMat returned null.\n");
 }
// printf ("newM: mo %p\n",mo);
  RETVAL = mo;
 OUTPUT:
  RETVAL


');


int rows(mw)
	matObj * mw;
	CODE:
	PDL_Indx r = rows(mw);
	RETVAL r;
	OUTPUT:
	RETVAL
