#!perl

use strict;
pp_addpm ({At=>'Top'},<<'EOPM');

use 5.10.0;


use Data::Dumper;

sub PDL::OpenCV::get_dp {
	my ($self,$p) = @_;
	barf ("get_dp: not a piddle! ") unless (ref($p) =~ /PDL/ );
	getD($$self,$p);
	say "data ref ",$p->get_dataref;
	$p->upd_data;
	$p;
}
EOPM

our $VERSION = 0.02;
pp_setversion($VERSION);

pp_bless ("PDL::OpenCV");

pp_addhdr << 'EOH';
 	#include "opencv_wrapper.h"
 	#include "generated_cvwrapper.h"
	// typedef TrackerWrapper trackerObj;
	typedef MatWrapper matObj;
	//MatWrapper * mw;

EOH
pp_addxs('','
MODULE = PDL::OpenCV PACKAGE = PDL::OpenCV

void * dataPtr (mo)
	matObj * mo
CODE:
	void * data_ptr = getData(mo);
	RETVAL = data_ptr;
OUTPUT: 
RETVAL


matObj *
newMW ()
 CODE:
matObj * mo= NULL;
mo=emptyMW();
if (mo==NULL) {
	barf("emptyMat returned null.\n");
}
  RETVAL = mo;
 OUTPUT:
  RETVAL


matObj *
nMat (c,r,p)
PDL_Indx c
PDL_Indx r
SV * p
CODE:
int t;
matObj * mo = NULL;
//char * type = SvRV( t );
pdl * pid = PDL->SvPDLV(p);
void * ptr =  pid->data ;
t=pid->datatype;
//printf ("dims %d\n",t );
int l=1;
if (pid->dims[0] <= 4) {
	l=pid->dims[0];
}
//float * dp = ptr;
//printf("cols %d rows %d type %d planes l %d ptr %p \n",r,c,t,l,ptr);
mo=newMat(c,r,t,l,ptr);
if (mo==NULL) {
	barf("emptyMat returned null.\n");
}
//printf ("newM: mo %p\n",mo);
//printf ("newM: data %p\n",getData(mo));
RETVAL = mo;
OUTPUT:
RETVAL


void  
getD(mo, p)
matObj *  mo
SV * p
CODE:
//mw = SvR
void * ptr =  mo;
matObj * mw =  ptr;
//printf ("getD *mo. %p\n",(*mo));
printf ("getD mo. %p\n",(mo));
printf ("getD mw. %p\n",mw);
pdl * pid = PDL->SvPDLV(p);
MatAt(mw,4,4);
printf ("getD data %p\n",getData(mw));
ptr =getData(mo);
float * fp = ptr;
pid->data=ptr;
printf("data (pid) 0,0 %f\n", fp[0]);

MODULE = PDL::OpenCV 		PACKAGE = matObjPtr PREFIX = mat_


void
mat_DESTROY(mw)
  matObj * mw
 CODE:
  deleteMat(mw);
  free (mw);


');

pp_def('vector_size',
	Pars=>'indx [o] vs();',
	OtherPars=>'MatWrapper * mw;PDL_Indx s',
	PMCode=>pp_line_numbers(__LINE__,'
		sub vector_size {
			my ($mw,$size) = @_;
			$size = -1 unless $size>=0;
			my $p=PDL->null;
			_vector_size_int($p,$$mw,$size);
			$p;
		}
	'),
	Code=>pp_line_numbers(__LINE__,'
		$vs()=vectorSize($COMP(mw),$COMP(s));
	'),
);

pp_def('vread', 
	Pars=>'m(c,r,f);',
	OtherPars=>'MatWrapper * mw; char * file',
	GenericTypes=>[qw/A B S U L F D/ ],
	PMCode=>pp_line_numbers(__LINE__,'
		sub vread {
			my ($mw,$name,$p)=@_;
			unless (ref ($p) =~ "PDL") {
				#say "rows ",$mw->rows;
				$p=PDL->null;
				#$p=zeroes(sclr ($mw->cols),sclr ($mw->rows),$mw->vector_size();
			}
			barf "cannot read file!" unless (-f $name);
			$p->make_physical;
			_vread_int($p,$$mw,$name);
			$p;
		}
		'
		),
	Code=>pp_line_numbers(__LINE__,'
		$PDL(m)->datatype=getDataCopy($COMP(mw),$P(m),$SIZE(f));
		if ($SIZE(f)<=0) {barf ("Failed to read video. %s.\n",$COMP(file));}
	'),
	RedoDimsCode=>pp_line_numbers(__LINE__,'
		$SIZE(c)=cols($COMP(mw),-1);
		$SIZE(r)=rows($COMP(mw),-1);
		$SIZE(f)=vread($COMP(mw),$COMP(file),$P(m));
		'),
		);

pp_def('new_mat',
	Pars=>'m(c,r);',
	GenericTypes=>[qw/A B S U L F D/ ],
	OtherPars=>'MatWrapper * mwi',
	Code=>pp_line_numbers(__LINE__,'
		//setData($COMP(mwi),$P(m),0);
		//printf ("after setData %f \n",MatAt($COMP(mwi),0,0));
		//printf ("after setData %f \n",$m(c=>0,r=>0));
		//printf ("data pointer %p \n",$P(m));
	'),
	PMCode=>pp_line_numbers(__LINE__,'
	sub new_mat{
		my ($class,$m)=@_;
		$m->make_physical;
		#say "type ",$m->type,", ",$m->get_datatype;
		my $mw = nMat($m->dim(0),$m->dim(1),$m); #,$m->get_dataref);
		bless $mw,$class;
		#_new_mat_int($m,$$mw);
		$mw;
	}',),
	Doc=><<"EOD",

=head2 new_mat - the constructor of a Mat() object.

From a 2-D piddle, a Mat is created. Note, that rows and cols are swapped.

EOD

);


pp_def ('get_data',
	Pars=>'[o] m(k,l);',
	OtherPars=>'MatWrapper * mw;',
	Code=>pp_line_numbers(__LINE__,
	'
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		PDL_Indx x = cols($COMP(mw),-1);
		PDL_Indx y = rows($COMP(mw),-1);
		//printf ("x %d : ks %d / y %d : ls %d\n ",x,ks,y,ls);
		if (x == ks && y == ls )
		{
			//double * ptr =$P(m);
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
			int t=getDataCopy($COMP(mw),$P(m),1); 
			printf ("get_data: type %d\n",t);
			$PDL(m)->datatype=t;
			printf ("get_data: piddle type %d\n",$PDL(m)->datatype);
			//$P(m)= ($PDL *) ptr;
		} else {
			$CROAK("Matrix size does not match!\n");
		}
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub get_data {
			my ($mw,$p,) = @_;
			unless (ref ($p) =~ "PDL") {
				#say "rows ",$mw->rows;
				$p=zeroes(sclr ($mw->cols),sclr ($mw->rows));
			}
			$p->make_physical;
			#$p->upd_data;
			say "ref to data" ,$p->get_dataref;
			_get_data_int($p,$$mw);
			#say "data type ", $p->type;
			say "(get_data) 4,4: ",$p->slice("4","4");
			#say "ref to data after " ,$p->get_dataref;
			#say "(get_data) 48,48: after",$p->slice("48","48");
			$p->transpose;
		}
		',),
	Doc=><<"EOD",

=head2 get_data - update data from a Mat object. Size and type should match.

EOD

	);


pp_def ('set_data',
	Pars=>'m(k,l);',
	OtherPars=>'MatWrapper * mw',
	GenericTypes=>[qw/A B S U L F D/ ],
	Code=>pp_line_numbers(__LINE__,
	'
			printf("m(3,1) %f \n",$m(k=>0,l=>0));
			setData($COMP(mw),$P(m),$PDL(m)->datatype);
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub set_data {
			my ($mw,$data) = @_;
			warn "This sets the Mat data pointer to the piddles. Apparently, this is unstable. Better use new_mat!\n";
			barf "no data supplied.\n" unless defined $data;
			barf "data has wrong dimensions.\n" unless ($data->dim(1) == $mw->rows &&  $mw->cols==$data->dim(0));
			$data->make_physical;
			_set_data_int(pdl($data),$$mw);
		}
	'),
	Doc=><<"EOD",

=head2 set_data - update data of a Mat object. Size and type should match.

EOD

	);




pp_add_boot (<< 'EOB');

	cv_init();
	//printf ("init done (autoinclude)\n");


EOB

pp_addpm(<<'EOPM');

sub data_ptr {
	my $mw=shift;
	dataPtr($$mw);
}

sub mat2pdl {
	my ($mw) = @_;
	my $p=PDL->new;
	$p->set_datatype($PDL_F);
	$p->setdims( [$mw->cols,$mw->rows]);
	my $dp=$p->get_dataref(data_ptr($mw));
	$p->upd_data;
}
EOPM

pp_def ('mat_at',
	Pars=>'double [o] m();',
	OtherPars=>'MatWrapper * mwi;int x;int y;',
	Code=>pp_line_numbers(__LINE__,
	'
		$m()=MatAt($COMP(mwi),$COMP(x),$COMP(y));
	',),
	PMCode=>pp_line_numbers(__LINE__,
	q{
	sub mat_at {
		my ($mw,$x,$y)=@_;
		my $o=zeroes(1);
		#say "pointer $$mw";
		_mat_at_int($o,$$mw,$x,$y);
		#say "$o";
		$o;
	}
	},
	),
);

pp_def('convertTo',
	Pars=>'',
	OtherPars=>'MatWrapper * mi; MatWrapper * mo; int type',
	PMCode=>pp_line_numbers(__LINE__,
<<'EOPM'),
		sub convertTo {
		my ($mi,$mo,$t) = @_;
		if (ref $mo ne q/PDL::OpenCV/) {
			$t=$mo if defined $mo;
			$mo=PDL::OpenCV::newMW();
		}
		barf "Not a valid data type $t\n" unless defined $t;
		_convertTo_int($$mi,$$mo,$t);
		bless($mo,'PDL::OpenCV');
		$mo;
	}
EOPM

	Code=>pp_line_numbers(__LINE__,
		'cw_convertTo($COMP(mi),$COMP(mo),$COMP(type)); '),
	);

pp_def('type',
	Pars=>'[io] cvt(); [io] pt();',
	OtherPars=>'MatWrapper * mi; ',
	Code=>pp_line_numbers(__LINE__, q{
		//int * pt = & $COMP(pdltyp);
		int t,ct;
		t = $pt();
		ct = $cvt();
		//printf ("cvt %d pd %d \n",ct,t);
		ct = cwtype($COMP(mi),& t);
		//printf ("cvt %d pd %d \n",$cvt(),$pt());
		$pt()=t;
		$cvt()=ct;
	} ),
	PMCode=>pp_line_numbers(__LINE__, q{
		sub type {
			my ($mw,$t) =@_;
			my $ct=pdl([-1]);
			$t=pdl([-1]) unless defined $t;
			#say $t->info,$ct->info;
			#say "t $t ct $ct";
			_type_int($t,$ct,$$mw,);
			$t=sclr $t;
			$ct=sclr $ct;
			#say "type $t cvtype $ct";
			($t,$ct);
		}
	}
	),
	);

sub protect_chars {
	my ($txt) = @_;
	$txt =~ s/>/E;gt#/g;
	$txt =~ s/</E;lt#/g;
	$txt =~ s/;/</g;
	$txt =~ s/#/>/g;
	return $txt;
}





sub ufunc {
    my ($name,$func,$overload,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $got_complex = PDL::Core::Dev::got_complex_version($func, 1);
    # handle exceptions
    my $badcode; # = '$ISBAD(a())';
    if ( exists $extra{Exception} ) {
#	$badcode .= " || $extra{Exception}";
#	print "Warning: ignored exception for $name\n";
	# NOTE This option is unused ($badcode is commented out above).
	#      See also `biop()`.
	delete $extra{Exception};
    }
    my $codestr = '
		//printf ("ufunc: mw %p\n",$COMP(mw)); 
		int res;
		res = '.$func.'($COMP(mw),$COMP(v));
		//printf ("res %d\n",res);
		$b() = res;' ;
    pp_def($name,
	   Pars => '[o]b()',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	   GenericTypes=>['N'],
	   PMCode => pp_line_numbers(__LINE__, qq{
		   sub $name {
			   my (\$self,\$v) = \@\_;
			   \$v = -1 unless defined \$v;
			   my \$res=zeroes(ushort,1);
			   say "$name calling now (\$v)";
			   _$name\_int(\$res,\$\$self,\$v);
			   say "res \$res?";
			   \$res;
		   }
	   },),
	   Code => pp_line_numbers(__LINE__, qq{
	           $codestr
	   }),
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.

=cut

EOD
} # sub: ufunc()

# generate functions.
map {ufunc($_,$_,0,"returns and optionally sets $_ of matrix. \n");} (qw/rows cols / );


pp_done();


__END__
use Inline C => Config =>
           enable => autowrap => LIBS => "-lopencv_wrapper" ;
 
use Inline C =>"#include <generated_cvwrapper.h>
int cw_convertTo ( MatWrapper * mw ,  MatWrapper * out, int type) ;
";

pp_def('cols2',
	Pars=>'[o] c();',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	GenericTypes=>['U'],
	Code=>'
		printf("cols2: (c) v: %d\n",$COMP(v));
		printf("cols2: (c) mw: %p\n",$COMP(mw));
		int r= cols($COMP(mw),$COMP(v));
		printf("cols2: (c) r: %d\n",r);
		$c()=r;',

	PMCode=>'   sub cols2 {
			   my ($self,$v) = @_;
			   $v = -1 unless defined $v;
			   my $res=zeroes(ushort,1);
			   say "cols2 calling now ($v)";
			   say "cols2 calling self ($$self)";
			   _cols2_int($res,$$self,$v);
			   say "res $res?";
			   $res;
		   }
	'
	);

pp_addxs('','
matObj *
newM (c,r,t)
        int c
        int r
        int t
 CODE:
matObj * mo = NULL;
 t=cvT.f32c1;
 mo=emptyMat(c,r,t);
 if (mo==NULL) {
         barf("emptyMat returned null.\n");
 }
// printf ("newM: mo %p\n",mo);
  RETVAL = mo;
 OUTPUT:
  RETVAL


');


int rows(mw)
	matObj * mw;
	CODE:
	PDL_Indx r = rows(mw);
	RETVAL r;
	OUTPUT:
	RETVAL
