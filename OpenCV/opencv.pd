#!perl

use strict;
pp_addpm ({At=>'Top'},<<"EOPM");

use 5.10.0;


use Data::Dumper;

sub rows {
}
EOPM

our $VERSION = 0.01;
pp_setversion($VERSION);

pp_bless ("PDL::OpenCV");

pp_addhdr << 'EOH';
 	#include "tracker_wrapper.h"
	typedef TrackerWrapper trackerObj;
	typedef MatWrapper matObj;
	//MatWrapper * mw;

EOH

pp_def ('get_data',
	Pars=>'i(k,l) ; float [o] m(k,l);',
	OtherPars=>'MatWrapper * mw; SV * res',
	Code=>pp_line_numbers(__LINE__,
	'
		/*
		pdl * p = PDL->SvPDLV($COMP(res));
		PDL_RETERROR(PDL_err, PDL->make_physical(p));
		printf ("data type %d",p->datatype);
		printf ("dims %d",p->datatype);
		*/
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		int x = cols($COMP(mw),-1);
		int y = rows($COMP(mw),-1);
		//printf ("x %d : ks %d / y %d : ls %d ",x,ks,y,ls);
		float * dat;
		if ( x == ks && y == ls )
		{
			//dat = (float *)getData($COMP(mw)); 
		//	$P(m)=dat;
			//p->data=dat;
			getDataCopy($COMP(mw),$P(m)); 
		} else {
			$CROAK("Matrix size does not match!\n");
		}
		int i,j;
		for (i =0 ; i<x; i++ ) {
			for (j =0 ; j<y; j++ ) {
				printf ("i %d,j %d: dat %f, in %f, ",i,j,$m(k=>i,l=>j),$i(k=>i,l=>j));  //dat[i*y+j]); //,p->data[i*x+j]);
				printf ("mat_at %f \n",MatAt($COMP(mw),i,j));  //dat[i*y+j]); //,p->data[i*x+j]);
				//$m(k=>i,l=>j) = dat[i*y+j]; //,p->data[i*x+j]);
			}
		}

		/*p->state |= PDL_DONTTOUCHDATA | PDL_ALLOCATED;
		*/
	'),
	PMCode=>pp_line_numbers(__LINE__,
	'
		sub get_data {
			my ($mw,$i,$p,) = @_;
			unless (ref ($p) =~ "PDL") {
				say "rows $mw->rows";
				$p=zeroes(float,$mw->cols,$mw->rows);
			}
			#$p->upd_data;
			#say "ref to data" ,$p->get_dataref;
			_get_data_int($i->transpose,$p,$$mw,PDL->null);
			say $i->info,$p->info;
			say "data type ", $p->type;
			#_get_data_int(zeroes(1,1),$$mw,$p);
			say "(get_data) 4,4: ",$p->slice("4","4");
			#say "ref to data after " ,$p->get_dataref;
			#say "(get_data) 48,48: after",$p->slice("48","48");
			$p->transpose;
		}
		',),
	Doc=><<"EOD",

=head2 get_data - update data from a Mat object. Size and type should match.

EOD

	);


pp_def ('set_data',
	Pars=>'m(k,l);',
	OtherPars=>'MatWrapper * mw',
	Code=>pp_line_numbers(__LINE__,
	'
		PDL_Indx ks = $SIZE(k);
		PDL_Indx ls = $SIZE(l);
		int * x;
		int * y;
		MatSize($COMP(mw),x,y);
		if (((*x) == ks) && ((*y) == ls))  {
			printf("m(0,0) %f \n",$m(k=>0,l=>0));
			setData($COMP(mw),$P(m),0);
		} else {
			$CROAK("Matrix size does not match!\n");

		}
	'),
	Doc=><<"EOD",

=head2 set_data - update data of a Mat object. Size and type should match.

EOD

	);


pp_def('new_mat',
	Pars=>'float m(c,r);',
	OtherPars=>'MatWrapper * mwi',
	Code=>pp_line_numbers(__LINE__,'
		setData($COMP(mwi),$P(m),0);
		printf ("after setData %f \n",MatAt($COMP(mwi),0,0));
	'),
	PMCode=>pp_line_numbers(__LINE__,'
	sub new_mat{
		my ($class,$m)=@_;
		my $mw = newM($m->dim(1),$m->dim(0),0); #,$m->get_dataref);
		_new_mat_int($m->transpose,$$mw);
		say "(new_mat perl) ",mat_at($mw,0,0);
		say $m->slice(0,0);
		bless $mw,$class;
	}',),
	Doc=><<"EOD",

=head2 new_mat - the constructor of a Mat() object.

From a 2-D piddle, a Mat is created. Note, that rows and cols are swapped.

EOD

);



pp_add_boot (<< 'EOB');

	cv_init();
	printf ("init done (autoinclude)\n");


EOB

pp_addpm(<<'EOPM');

sub data_ptr {
	my $mw=shift;
	dataPtr($$mw);
}

sub mat2pdl {
	my ($mw) = @_;
	my $p=PDL->new;
	$p->set_datatype($PDL_F);
	$p->setdims( [$mw->cols,$mw->rows]);
	my $dp=$p->get_dataref(data_ptr($mw));
	$p->upd_data;
}
EOPM

pp_def ('mat_at',
	Pars=>'[o] m();',
	OtherPars=>'MatWrapper * mwi;int x;int y;',
	Code=>pp_line_numbers(__LINE__,
	'
		printf ("at: mwi %p\n",$COMP(mwi));
		float f=MatAt($COMP(mwi),$COMP(x),$COMP(y));
		$m()=f;
	',),
	PMCode=>pp_line_numbers(__LINE__,
	q{
	sub mat_at {
		my ($mw,$x,$y)=@_;
		my $o=zeroes(1);
		_mat_at_int($o,$$mw,$x,$y);
		#say "$o";
		$o;
	}
	},
	),
);
pp_addxs('','
MODULE = PDL::OpenCV PACKAGE = PDL::OpenCV

void * dataPtr (mo)
	matObj * mo
CODE:
	void * data_ptr = getData(mo);
	RETVAL = data_ptr;
OUTPUT: 
RETVAL

matObj *
newM (c,r,t)
        int c
        int r
        int t
 CODE:
matObj * mo = NULL;
 t=cvT.f32c1;
 mo=emptyMat(c,r,t);
 
 if (mo==NULL) {
         barf("emptyMat returned null.\n");
 }
 printf ("newM: mo %p\n",mo);
  RETVAL = mo;
 OUTPUT:
  RETVAL


matObj *
newMW ()
 CODE:
matObj * mo= emptyMW();
  RETVAL = mo;
 OUTPUT:
  RETVAL

MODULE = PDL::OpenCV PACKAGE = matObj PREFIX = mat_


void
destroy(mw)
  matObj * mw
 CODE:
  deleteMat(mw);


');

sub protect_chars {
  my ($txt) = @_;
  $txt =~ s/>/E;gt#/g;
  $txt =~ s/</E;lt#/g;
  $txt =~ s/;/</g;
  $txt =~ s/#/>/g;
  return $txt;
}





sub ufunc {
    my ($name,$func,$overload,$doc,%extra) = @_;
    my $funcov = ref $func eq 'ARRAY' ? $func->[1] : $func;
    my $funcovp = protect_chars $funcov;
    $func = $func->[0] if ref $func eq 'ARRAY';
    my $got_complex = PDL::Core::Dev::got_complex_version($func, 1);
    # handle exceptions
    my $badcode = '$ISBAD(a())';
    if ( exists $extra{Exception} ) {
#	$badcode .= " || $extra{Exception}";
#	print "Warning: ignored exception for $name\n";
	# NOTE This option is unused ($badcode is commented out above).
	#      See also `biop()`.
	delete $extra{Exception};
    }
    my $codestr = '
	//	printf ("ufunc: mw %p\n",$COMP(mw)); 
		int res;
		res = '.$func.'($COMP(mw),$COMP(v));
		//printf ("res %d\n",res);
		$b() = res;' ;
    pp_def($name,
	   Pars => '[o]b()',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	   GenericTypes=>['U'],
	   PMCode => pp_line_numbers(__LINE__, qq{
		   sub $name {
			   my (\$self,\$v) = \@\_;
			   \$v = -1 unless defined \$v;
			   my \$res=zeroes(ushort,1);
			   say "$name calling now (\$v)";
			   _$name\_int(\$res,\$\$self,\$v);
			   say "res \$res?";
			   \$res;
		   }
	   },),
	   Code => pp_line_numbers(__LINE__, qq{
	           $codestr
	   }),
	   %extra,
	   Doc => << "EOD");
=for ref

$doc

=for example

   \$y = $funcov \$x;
   \$x->inplace->$name;  # modify \$x inplace

It can be made to work inplace with the C<\$x-E<gt>inplace> syntax.
This function is used to overload the unary C<$funcovp> operator/function.

=cut

EOD
} # sub: ufunc()

# generate functions.
map {ufunc($_,$_,0,"returns and optionally sets $_ of matrix. \n");} (qw/rows cols type/);


pp_done();


__END__
pp_def('cols2',
	Pars=>'[o] c();',
	   OtherPars=>'MatWrapper * mw; PDL_Indx v',
	GenericTypes=>['U'],
	Code=>'
		printf("cols2: (c) v: %d\n",$COMP(v));
		printf("cols2: (c) mw: %p\n",$COMP(mw));
		int r= cols($COMP(mw),$COMP(v));
		printf("cols2: (c) r: %d\n",r);
		$c()=r;',

	PMCode=>'   sub cols2 {
			   my ($self,$v) = @_;
			   $v = -1 unless defined $v;
			   my $res=zeroes(ushort,1);
			   say "cols2 calling now ($v)";
			   say "cols2 calling self ($$self)";
			   _cols2_int($res,$$self,$v);
			   say "res $res?";
			   $res;
		   }
	'
	);


int rows(mw)
	matObj * mw;
	CODE:
	int r = rows(mw);
	RETVAL r;
	OUTPUT:
	RETVAL
