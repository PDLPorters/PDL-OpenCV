#!perl

use strict;
use warnings;
use JSON::PP;
use File::Basename;
use File::Spec::Functions;
use Cwd;
use IPC::Open2;
use Data::Dumper;

my $HEADERS = 'maint/headers.txt';
my $HEADERS_DIR = '/usr/include/opencv4';
my $CVDIR = '../opencv/modules/python/src2';
my $PYSCRIPT = <<'EOF';
import hdr_parser, json, sys
parser = hdr_parser.CppHeaderParser()
json.dump([[x,parser.parse(x)] for x in sys.stdin.read().splitlines()], sys.stdout)
EOF

my @HEADERS_FILES = do { local @ARGV = $HEADERS; grep !/^\s*#/, <> };
chomp @HEADERS_FILES;

my $json_data;
{
my $old_dir = getcwd();
chdir $CVDIR or die "chdir: $!";
my $pid = open2(my $child_out, my $child_in, qw(python3 -c), $PYSCRIPT);
print $child_in map catfile($HEADERS_DIR, $_)."\n", @HEADERS_FILES;
close $child_in;
$json_data = decode_json do { local $/; <$child_out> };
chdir $old_dir or die "chdir: $!";
}

my %force = map +($_=>1), qw(
  cv.batchDistance
  cv.sum
  cv.wrapperEMD
  cv.GeneralizedHough.detect
  cv.Algorithm.read
  cv.Algorithm.write
  cv.FileNode.keys
  cv.FileStorage.getFirstTopLevelNode
  cv.FileStorage.operator[]
  cv.KeyPoint.overlap
  cv.KeyPoint.convert
  cv.cvtColor
  cv.rectangle
  cv.ellipse2Poly
  cv.getAffineTransform
  cv.getGaborKernel
  cv.drawContours
  cv.findContours
  cv.threshold
  cv.hconcat
  cv.mixChannels
  cv.logPolar
  cv.equalizeHist
  cv.normalize
  cv.minMaxLoc
  cv.imread
  cv.imencode
  cv.imshow
  cv.waitKey
  cv.namedWindow
  cv.selectROI
  cv.destroyWindow
  cv.VideoCapture.read
  cv.VideoCapture.open
  cv.VideoCapture.get
  cv.VideoCapture.getBackendName
  cv.VideoWriter.open
  cv.VideoWriter.write
  cv.VideoWriter.fourcc
  cv.cvtColorTwoPlane
  cv.LineSegmentDetector.compareSegments
  cv.LineSegmentDetector.detect
  cv.LineSegmentDetector.drawSegments
  cv.Subdiv2D.initDelaunay
  cv.Subdiv2D.insert
  cv.Subdiv2D.getTriangleList
  cv.Subdiv2D.getVoronoiFacetList
  cv.QRCodeDetector.detectAndDecodeMulti
  cv.groupRectangles
  cv.CascadeClassifier.load
  cv.CascadeClassifier.detectMultiScale
  cv.HOGDescriptor.detectMultiScale
  cv.Tracker.init
  cv.Tracker.update
);
my %class = map +($_=>1), qw(
  LineSegmentDetector Tracker VideoCapture VideoWriter QRCodeDetector
  CascadeClassifier Subdiv2D TrackerKCF TrackerCSRT TrackerMIL
  FileNode FileStorage DMatch KeyPoint Algorithm CLAHE GeneralizedHough
  HOGDescriptor
);
my $no_want = qr/^(TermCriteria|RNG|RotatedRect)/;

if (@ARGV) {
  die "Usage: $0 [json]" if @ARGV != 1 or $ARGV[0] ne 'json';
  print Dumper $json_data;
  exit;
}
my (%dest2enums, %dest2func2name2defs, %dest2classdefs, %dest2class2create);
for (@$json_data) {
  my ($file, $d) = @$_;
  my $dest = $file =~ /core/ ? "" : basename($file, ".hpp");
print "$file -> |$dest|\n";
  for my $t (@$d) {
    my ($name, $ret, $flags, $args, $ret_cpp, $doc) = @$t;
    if ($name =~ /^enum\s+/) {
print "enum: $name\n";
      for my $t (@$args) {
        my ($ename) = @$t;
        die "badly-formatted enum name $ename\n" if !(my ($pname) = $ename =~ /^const\s+(cv\..+)/);
        $pname =~ s#\.#::#g;
        push @{$dest2enums{$dest}}, $pname;
      }
    } elsif ($name =~ /^(?:class|struct) cv\.(.*)/) {
      my $cname = $1;
      next if !$class{$cname};
      $ret =~ s/^:\s*//;
      $ret = [map {(my $r=$_)=~s/^cv:://;$r} split /\s*,\s*/, $ret];
print "class: $cname\n";
      push @{$dest2classdefs{$dest}}, [$cname, $ret, $doc];
    } elsif ($ret =~ /^Ptr_/ and $name =~ /^cv\.(.*)\.create/) {
      my $cname = $1;
print "class::create: $cname\n";
      $name =~ s/\./::/g;
      $args = [] if @$args == 1 and $args->[0][0] =~ /Params/;
      $dest2class2create{$dest}{$cname} = [1, $name, $args, $doc];
    } elsif ($ret =~ /^Ptr_/ and $name =~ /^cv\.(create(.*))/) {
      my ($full, $cname) = ($1, $2);
print "classcreate: $cname\n";
      $dest2class2create{$dest}{$cname} = [1, "cv::$full", $args, $doc];
    } elsif ($name =~ /^cv\.([^.]+)\.\1/) { # Python constructors
      my $cname = $1;
print "class.class: $cname\n";
print(" skipping with @{[0+@$args]}\n"), next if @$args; # temporary
      $dest2class2create{$dest}{$cname} = [0, "cv::$cname", $args, $doc];
    } elsif ($force{$name}) {
      my (undef, @n) = split /\./, $name;
      unshift @n, '' if @n == 1;
      die "Unexpected number of elts in (@n)" if @n != 2;
      my $ismethod = 0+(!!$n[0] && !grep $_ eq '/S', @$flags);
      my @aliases = grep /^=/, @$flags;
      die ">1 aliases for $name: @aliases" if @aliases > 1;
      if (@aliases) {
        die "alias for $name no '=': $aliases[0]" unless $aliases[0] =~ s/^=//;
        $n[1] = [$n[1], $aliases[0]];
        $name .= "/$aliases[0]";
      }
      push @n, $doc, $ismethod, $ret, @$args;
      push @{$dest2func2name2defs{$dest}{$name}}, \@n;
      print "$name\n";
    }
  }
}

for my $bits (qw(8U 8S 16U 16S 32S 32F 64F)) {
  push @{$dest2enums{''}}, "CV_${bits}", (map "CV_${bits}C$_", 1..4), "CV_${bits}C|int n";
}
push @{$dest2enums{''}}, qw(CV_PI CV_2PI CV_LOG2 INT_MAX);

writefile($_, 'constlist.txt', $dest2enums{$_}) for keys %dest2enums;

my %dest2funcs;
for my $dest (keys %dest2func2name2defs) {
  for my $name (sort keys %{$dest2func2name2defs{$dest}}) {
    push @{$dest2funcs{$dest}}, selectdef($name, $dest2func2name2defs{$dest}{$name});
  }
}

sub selectdef {
  my ($name, $defs) = @_;
  my @defs = grep $_->[4] !~ $no_want && (!grep !ref() || $_->[0] =~ $no_want, @$_[5..$#$_]), @$defs; # remove any with non-handled return-type or args
  print("none left for $name\n"), return if !@defs; # no candidates!
  return $defs[0] if @defs == 1;
  @defs = grep $_->[2] ne '@overload', @defs;
  return $defs[0] if @defs == 1;
  my @schw = map [scalar @$_, do {my $tot = 0; $tot += length $_->[0] for @$_[5..$#$_]; $tot}, $_], @defs;
  @schw = sort { $b->[0] <=> $a->[0] || $b->[1] <=> $a->[1] } @schw; # descending order of number of args, then length of arg-types
  $schw[0][2];
}

sub genfile {
  my ($d) = @_;
  local $Data::Dumper::Indent = 0;
  local $Data::Dumper::Sortkeys = 1;
  local $Data::Dumper::Terse = 1;
  ["(", (map Dumper($_).",", @$d), ");"];
}

sub writefile {
  my ($dest, $filebase, $list) = @_;
  my $file = $dest ? catfile(ucfirst($dest), $filebase) : $filebase;
  my $dir = ucfirst $dest;
  if ($dest and !-d $dir) {
    my %n2f = (
    'Makefile.PL' => "wmf('$dir', ['$dest']);\n",
    'module.pd' => <<EOF,
use strict;
use warnings;
use File::Spec::Functions;
require ''.catfile(updir, 'genpp.pl');

genheader("$dir");

pp_done();
EOF
    );
    mkdir $dir or die "$dir: $!";
    for (keys %n2f) {
      my $file = catfile($dir, $_);
      open my $fh, , '>', $file or die "$file: $!";
      print $fh $n2f{$_};
    }
  }
  my $new = join '', map "$_\n", @$list;
  my $old = -f $file ? do { local $/; open my $fh, '<', $file or die "$file: $!"; <$fh> } : '';
  return if $new eq $old;
  open my $fh, '>', $file or die "$file: $!";
  print $fh $new;
}

writefile($_, 'funclist.pl', genfile($dest2funcs{$_})) for keys %dest2funcs;

for my $dest (keys %dest2classdefs) {
  for my $c (@{$dest2classdefs{$dest}}) {
    next unless my $extra = $dest2class2create{$dest}{$c->[0]};
    push @$c, @$extra;
  }
}
writefile($_, 'classes.pl', genfile($dest2classdefs{$_})) for keys %dest2classdefs;
