#!perl

use strict;
use warnings;
use JSON::PP;
use File::Basename;
use File::Spec::Functions;
use Cwd;
use IPC::Open2;
use Data::Dumper;

my $HEADERS = 'maint/headers.txt';
my $HEADERS_DIR = '/usr/include/opencv4';
my $CVDIR = '../opencv/modules/python/src2';
my $PYSCRIPT = <<'EOF';
import hdr_parser, json, sys
parser = hdr_parser.CppHeaderParser()
json.dump([[x,parser.parse(x)] for x in sys.stdin.read().splitlines()], sys.stdout)
EOF

my @HEADERS_FILES = do { local @ARGV = $HEADERS; grep !/^\s*#/, <> };
chomp @HEADERS_FILES;

my $json_data;
{
my $old_dir = getcwd();
chdir $CVDIR or die "chdir: $!";
my $pid = open2(my $child_out, my $child_in, qw(python3 -c), $PYSCRIPT);
print $child_in map catfile($HEADERS_DIR, $_)."\n", @HEADERS_FILES;
close $child_in;
$json_data = decode_json do { local $/; <$child_out> };
chdir $old_dir or die "chdir: $!";
}

my %force = map +($_=>1), qw(
  cv.cvtColor
  cv.rectangle
  cv.logPolar
  cv.normalize
  cv.minMaxLoc
  cv.imshow
  cv.waitKey
  cv.namedWindow
  cv.selectROI
  cv.destroyWindow
  cv.VideoCapture.read
  cv.VideoCapture.open
  cv.VideoCapture.get
  cv.VideoWriter.open
  cv.VideoWriter.write
  cv.VideoWriter.fourcc
);

#use Data::Dumper; print Dumper $json_data;
my (%dest2enums, %dest2func2name2defs);
for (@$json_data) {
  my ($file, $d) = @$_;
  my $dest = $file =~ /core/ ? "" : basename($file, ".hpp");
print "$file -> |$dest|\n";
  for my $t (@$d) {
    my ($name, undef, undef, $tuples) = @$t;
    if ($name =~ /^enum\s+/) {
print "enum: $name\n";
      for my $t (@$tuples) {
        my ($ename) = @$t;
        die "badly-formatted enum name $ename\n" if !(my ($pname) = $ename =~ /^const\s+(cv\..+)/);
        $pname =~ s#\.#::#g;
        push @{$dest2enums{$dest}}, $pname;
      }
    } elsif ($force{$name}) {
      my ($name, $ret, $flags, $args, $ret_cpp, $doc) = @$t;
      my (undef, @n) = split /\./, $name;
      unshift @n, '' if @n == 1;
      my $ismethod = 0+!!$n[0];
      $ismethod = 0 if grep $_ eq '/S', @$flags;
      push @n, $doc, $ismethod, $ret, @$args;
      push @{$dest2func2name2defs{$dest}{$name}}, \@n;
      print "$name\n";
    }
  }
}

for my $bits (qw(8UC 8SC 16UC 16SC 32SC 32FC 64FC)) {
  push @{$dest2enums{''}}, (map "CV_$bits$_", 1..4), "CV_$bits|int n";
}

for my $dest (keys %dest2enums) {
  my $d = $dest2enums{$dest};
  my $file = $dest ? catfile(ucfirst($dest), 'constlist.txt') : 'constlist.txt';
  open my $fh, '>', $file or die "$file: $!";
  print $fh map "$_\n", @$d;
}

my %dest2funcs;
for my $dest (keys %dest2func2name2defs) {
  for my $name (sort keys %{$dest2func2name2defs{$dest}}) {
    my @defs = @{ $dest2func2name2defs{$dest}{$name} };
    @defs = grep +(!grep !ref() || $_->[0] =~ /^(vector_|TermCriteria|RNG)/, @$_[5..$#$_]), @defs; # remove any with vector args
    print("none left for $name\n"), next if !@defs; # no candidates!
    push(@{$dest2funcs{$dest}}, $defs[0]), next if @defs == 1;
    @defs = grep $_->[2] ne '@overload', @defs;
    push(@{$dest2funcs{$dest}}, $defs[0]), next if @defs == 1;
    @defs = sort { @$b <=> @$a } @defs; # descending order of number of args
    push(@{$dest2funcs{$dest}}, $defs[0]);
  }
}

for my $dest (keys %dest2funcs) {
  my $d = $dest2funcs{$dest};
  my $file = $dest ? catfile(ucfirst($dest), 'funclist.pl') : 'funclist.pl';
  open my $fh, '>', $file or die "$file: $!";
  local $Data::Dumper::Indent = 0;
  local $Data::Dumper::Sortkeys = 1;
  local $Data::Dumper::Terse = 1;
  print $fh "(\n";
  print $fh Dumper($_).",\n" for @$d;
  print $fh ");\n";
}
