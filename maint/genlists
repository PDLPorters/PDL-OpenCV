#!perl

use strict;
use warnings;
use JSON::PP;
use File::Basename;
use File::Spec::Functions;
use Cwd;
use IPC::Open2;
use Data::Dumper;

my $HEADERS = 'maint/headers.txt';
my $HEADERS_DIR = '/usr/include/opencv4';
my $CVDIR = '../opencv/modules/python/src2';
my $PYSCRIPT = <<'EOF';
import hdr_parser, json, sys
parser = hdr_parser.CppHeaderParser()
json.dump([[x,parser.parse(x)] for x in sys.stdin.read().splitlines()], sys.stdout)
EOF

my @HEADERS_FILES = do { local @ARGV = $HEADERS; grep !/^\s*#/, <> };
chomp @HEADERS_FILES;

my $json_data;
{
my $old_dir = getcwd();
chdir $CVDIR or die "chdir: $!";
my $pid = open2(my $child_out, my $child_in, qw(python3 -c), $PYSCRIPT);
print $child_in map catfile($HEADERS_DIR, $_)."\n", @HEADERS_FILES;
close $child_in;
$json_data = decode_json do { local $/; <$child_out> };
chdir $old_dir or die "chdir: $!";
}

my %force = map +($_=>1), qw(
  cv.batchDistance
  cv.cvtColor
  cv.rectangle
  cv.ellipse2Poly
  cv.getAffineTransform
  cv.getGaborKernel
  cv.logPolar
  cv.normalize
  cv.minMaxLoc
  cv.imread
  cv.imshow
  cv.waitKey
  cv.namedWindow
  cv.selectROI
  cv.destroyWindow
  cv.VideoCapture.read
  cv.VideoCapture.open
  cv.VideoCapture.get
  cv.VideoCapture.getBackendName
  cv.VideoWriter.open
  cv.VideoWriter.write
  cv.VideoWriter.fourcc
  cv.LineSegmentDetector.compareSegments
  cv.LineSegmentDetector.detect
  cv.LineSegmentDetector.drawSegments
);
my %class = map +($_=>1), qw(
  LineSegmentDetector Tracker VideoCapture VideoWriter
);

if (@ARGV) {
  die "Usage: $0 [json]" if @ARGV != 1 or $ARGV[0] ne 'json';
  print Dumper $json_data;
  exit;
}
my (%dest2enums, %dest2func2name2defs, %dest2classdefs);
for (@$json_data) {
  my ($file, $d) = @$_;
  my $dest = $file =~ /core/ ? "" : basename($file, ".hpp");
print "$file -> |$dest|\n";
  for my $t (@$d) {
    my ($name, undef, undef, $tuples) = @$t;
    if ($name =~ /^enum\s+/) {
print "enum: $name\n";
      for my $t (@$tuples) {
        my ($ename) = @$t;
        die "badly-formatted enum name $ename\n" if !(my ($pname) = $ename =~ /^const\s+(cv\..+)/);
        $pname =~ s#\.#::#g;
        push @{$dest2enums{$dest}}, $pname;
      }
    } elsif ($name =~ /^class cv\.(.*)/) {
      my $cname = $1;
      next if !$class{$cname};
print "class: $cname\n";
      push @{$dest2classdefs{$dest}}, [$cname, $t->[5]];
    } elsif ($force{$name}) {
      my ($name, $ret, $flags, $args, $ret_cpp, $doc) = @$t;
      my (undef, @n) = split /\./, $name;
      unshift @n, '' if @n == 1;
      my $ismethod = 0+!!$n[0];
      $ismethod = 0 if grep $_ eq '/S', @$flags;
      push @n, $doc, $ismethod, $ret, @$args;
      push @{$dest2func2name2defs{$dest}{$name}}, \@n;
      print "$name\n";
    }
  }
}

for my $bits (qw(8U 8S 16U 16S 32S 32F 64F)) {
  push @{$dest2enums{''}}, "CV_${bits}", (map "CV_${bits}C$_", 1..4), "CV_${bits}C|int n";
}
push @{$dest2enums{''}}, qw(CV_PI CV_2PI CV_LOG2);

writefile($_, 'constlist.txt', $dest2enums{$_}) for keys %dest2enums;

my %dest2funcs;
my $no_want = qr/^(vector_(Mat|vector)|TermCriteria|RNG|RotatedRect|Ptr_CLAHE|Ptr_GeneralizedHough|Ptr_LineSegmentDetector|Ptr_Tracker)/;
for my $dest (keys %dest2func2name2defs) {
  for my $name (sort keys %{$dest2func2name2defs{$dest}}) {
    my @defs = @{ $dest2func2name2defs{$dest}{$name} };
    @defs = grep $_->[4] !~ $no_want && (!grep !ref() || $_->[0] =~ $no_want, @$_[5..$#$_]), @defs; # remove any with vector etc return-type or args
    print("none left for $name\n"), next if !@defs; # no candidates!
    push(@{$dest2funcs{$dest}}, $defs[0]), next if @defs == 1;
    @defs = grep $_->[2] ne '@overload', @defs;
    push(@{$dest2funcs{$dest}}, $defs[0]), next if @defs == 1;
    @defs = sort { @$b <=> @$a } @defs; # descending order of number of args
    push(@{$dest2funcs{$dest}}, $defs[0]);
  }
}

sub genfile {
  my ($d) = @_;
  local $Data::Dumper::Indent = 0;
  local $Data::Dumper::Sortkeys = 1;
  local $Data::Dumper::Terse = 1;
  ["(", (map Dumper($_).",", @$d), ");"];
}

sub writefile {
  my ($dest, $filebase, $list) = @_;
  my $file = $dest ? catfile(ucfirst($dest), $filebase) : $filebase;
  my $new = join '', map "$_\n", @$list;
  my $old = -f $file ? do { local $/; open my $fh, '<', $file or die "$file: $!"; <$fh> } : '';
  return if $new eq $old;
  open my $fh, '>', $file or die "$file: $!";
  print $fh $new;
}

writefile($_, 'funclist.pl', genfile($dest2funcs{$_})) for keys %dest2funcs;

$dest2classdefs{tracking} = [['Tracker','@brief Object-tracker in images']];
writefile($_, 'classes.pl', genfile($dest2classdefs{$_})) for keys %dest2classdefs;
